/** @brief 
Глава 11 Страуструпа
Глава 3 Лаптева
Операторы которые можно или нельзя перегрузить.
Операторы члены и не-члены классов. 
Операторы, которые можно перегрузить только членами классов.
Операторы, которые лучше перегрузить функцией.
Неоднозначность перегрузки операторов.
Операторы в пространствах имен.
Неявное преобразование '=' в конструкторе и его запрещение.
Операторы преобразования типов.
Друзья класса.
Работа со значениями и ссылками. Кэширование и оптимизация при работе со значениями.
*/

/*
Сделать:
1. Класс строки, реализованный в главе 11, разобраться как работает.
2. Объединение функций-друзей в namespace.
3. Операторы для перечислений (Страуструп стр. 313)
*/

/*
Вопросы:
*/

/** Советы:
1. Определяйте интуитивно понятные операторы.
2. Передавайте параметры по константной ссылке.
3. Оптимизируйте возвращаемое значение если объект большой 
   (например с помощью статического кэша, синглтона)
4. Если копирование и присваивание по умолчанию ОК, не перегружайте их.
5. Можно запрещать копирование и присваивание, если это необходимо.
6. Используйте глубокое копирование в классах с динамической памятью.
7. Коммутативные операции и операции ввода-вывода перегружайте функциями.
   Остальные перегружайте методами.
8. Пользуйтесь пространствами имен для связи функций-друзей с их классом.
9. Пользуйтесь оператором () для многомерной индексации.
10.Перегружайте 2 формы () и [] для константной и неконстантной версии
	(неконстантная должна возвращать ссылку чтобы быть l-value)
11.Объявляйте конструкторы с единственным аргументом как explicit
   если хотите запретить неявные преобразования (например, если этот аргумент - размер)
12.Будьте осторожны при перегрузке операторов приведения типа 
   - могут возникнуть неоднозначности или неявные сложноуловимые приведения.
13.Операторы [] () = -> {type} могут быть только членами класса.
14.Нельзя перегружать операторы   ::	.	.*	?:
15.В операторах нельзя использовать параметры по умолчанию, 
   т.к. иначе теоретически можно сделать бинарную ф-цию унарной
16.Для перечислений также можно вводить операторы.
17.В операторах доступа к представлению типа += *= = возвращается текущий объект 
   (чтобы он был l-value). Это можно явно запретить при необходимости,
   возвращая константную ссылку.
18.Префиксная форма оператора инкремента возвращает ссылку, постфиксная - значение.
19.При перегрузке операторов реализуйте основные операции, 
   а потом реюзайте их код в других операторах (+= +, -= -  т.д.)
20.При перегрузке опрераторов приведения типа значение не возвращается.
21.Друзей можно объявлять в закрытой или открытой части класса - не имеет значения.
22.Объект неявно копируется при передаче или возвращению по значению и при бросании исключения.
23.Копирующие операции НЕ НАСЛЕДУЮТСЯ.
24.Оператор -> реализует концепцию косвенного доступа (например в итераторах)
25.Новые операции можно объявлять, реализовав класс-обертку над встроенным типом
   (например double - class real, и в нем реализовать возведение в степень)
*/