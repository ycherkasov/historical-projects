#include <memory>
#include "autoptr.h"
using std::auto_ptr;

// Пример стандартного умного указателя
// В классах умных указателей, во избежание сюрпризов, конструкторы по указателям обычно объявляют explicit
// у std::auto_ptr конструктор принимает обычую ссылку, а не константную (для деструктивного копирования)
// копирующий конструктор с константной ссылкой при этом больше не генерируется

// Кстати, в самописном умном указателе копирующий конструктор можно вообще сделать закрытым. 
// Тот, кто захочет забрать владение у объекта, обозначаемого lvalue, 
// может продемонстрировать своё намерение явно посредством вызова функции move

// Не используйте неявное преобразование умного указателя в обычный!

void test_autoptr(){

	struct test_auto
	{
		test_auto() : a(), b(){}
		int a;
		double b;
	};

	auto_ptr<test_auto> ap1 (new test_auto() ) ;

	test_auto* pa = new test_auto();
	
	// вступаем во владение
	auto_ptr<test_auto> ap2(pa);

	// передаем владение ap3 (ap2 утрачивает его)
	auto_ptr<test_auto> ap3(ap2);

	// Этот принцип назвается семантикой владения 
	// (или деструктивного копирования)

	// ошибка: ap2 уже утратил владение pa
	//ap2->a = 6;

	// получаем указатель на обернутый объект
	const test_auto* pa1 = ap3.get();

	// ошибка - вступаем во владение объектом дважды (UB)
	// auto_ptr<test_auto> ap4(pa);

	// константный auto_ptr - не только не м.б. изменен
	// но и не может передать права на владение указателем
	const auto_ptr<test_auto> apconst(new test_auto());
	
	// ошибка: т.к. копирование переменной const auto_ptr 
	// изменяет ее саму, оно запрещено
	// ap2 = apconst;

	// Это достигается с помощью вспомогательного типа auto_ptr_ref

	// нельзя использовать в качестве элементов контейнера стандартный указатель auto_ptr,
	// потому что операция копирования auto_ptr зануляет исходный указатель
}
