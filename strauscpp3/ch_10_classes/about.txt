Глава 10 Страуструпа
Главы 1,2,4,5 Лаптева
Глава 2,4 Мейерса 1 (operator new/delete, проектирование)
Глава 4, 5(29, 30), 6 Мейерса 2 (Эффективность, Приемы, Разное)
В проекте рассматриваются классы, члены классов, 
константные и статические члены классов,
константные и статические классы,
mutable, временные объекты, объединения.


Вопросы:

Сделать:

Пример production реализации memory pool
http://www.pjsip.org/pjlib/docs/html/files.htm

Простые примеры
http://www.codeproject.com/Articles/27487/Why-to-use-memory-pool-and-how-to-implement-it
http://www.codeproject.com/Articles/15527/C-Memory-Pool
http://stackoverflow.com/questions/16378306/c11-memory-pool-design-pattern

// Facebook jemalloc
https://www.facebook.com/notes/facebook-engineering/scalable-memory-allocation-using-jemalloc/480222803919

Windows Low fragmentation heap
http://msdn.microsoft.com/en-us/library/aa366750.aspx



As for fragmentation: it still depends. Unfortunately I can't find the link now, 
but I remember a blog post from somebody at Microsoft who had worked on a C++ server 
application that suffered from memory fragmentation. The team solved the problem by 
allocating memory from two regions. Memory for all requests would come from region A 
until it was full (requests would free memory as normal). 
When region A was full, all memory would be allocated from region B. 
By the time region B was full, region A was completely empty again. 
This solved their fragmentation problem.

operator delete is unique in being a non-member or static member function that is dynamically dispatched
A type with a virtual destructor performs the call to its own delete from the most derived destructor
http://en.cppreference.com/w/cpp/memory/new/operator_new
http://en.cppreference.com/w/cpp/language/delete
http://en.cppreference.com/w/cpp/memory/new/operator_delete


Советы
1. Представляйте все концепции в виде классов.
2. Пользуйтесь структурами если класс маленький 
   либо является просто композицией разнородных данных.
3. Не добавляйте в класс большое число конструкторов, просто потому 
   что они когда-нибудь могут понадобиться.
4. Объявляйте по возможности функции-члены как const.
5. При копировании проверяйте копирование самому себе.
6. Можно пользоваться неименованными перечислениями для объявления констант.
7. Глобальным объектам предпочитайте синглтоны.
8. Закрытые данные следует помещать в конец класса, чтобы сделать акцент на открытом интерфейсе.
9. Корректно определяйте константный указатель  - char *const p;
   и указатель на константу char const* p (const char* p)
10.Неконстантный метод не м.б. вызван в константном экземпляре.
11.При необходимости пользуйтесь запрещением копирования.
12.Отличия конструктора от метода - конструктор не м.б. виртуальным или статическим,
   не возвращает результата.
13.Элементы массива-члена могут быть сконструированы только по умолчанию.
   Это делает практически безполезными константные массивы-члены.
   Исключение составляет статический массив.
14.Конструкторы глобальных объектов вызываются в одном модуле - в порядке определения,
   в разных модулях - порядок не определен. То же для разрушения объектов.
15.Конструкторы статических объектов вызываются при первом использовании, 
   разрушаются в порядке, обратном конструированию. Момент разрушения не определен.
16.Член объединения (union) не может иметь членов с конструкторами-деструкторами
   т.к. в общем случае непонятно какой из них вызывать.
17.В конструкторе по умолчанию используйте аргументы по умолчанию.
18.Если класс содержит константы или ссылки в качестве членов,
   конструктор по умолчанию не может быть вызван.
19.Нестатический массив-член может быть проинициализирован нулями ()
20.Существует неоднозначность при вызове целочисленных параметров и указателей (передача 0 - int)
   Они также наследуются всеми потомками класса. Решение - специализация шаблонов T*
22.При возвращении больших объектов по значению пользуйтесь оптимизацией в виде
   RVO (вызов конструктора после return).
23.Существуют 3 формы оператора new.
24.В некоторых случаях (замещающий вызов new) деструктор может быть вызван явно.
25.Размер класса не всегда равен размеру его членов (выравнивание)
26.Набор эффективных конкретных классов составляет фундамент приложения.
   Тщательно проектируйте классы.
27. Разрешается определять структуру и не структуры одного имени (то же для class, enum, union)
28. При замещении operator new() делайте его членом класса (иначе он перекроет стандартный new).
29. Компилятор не сгенерирует константный operator=(const A&) если явно определен неконстантный operator=(A&)!
30. При нехватке памяти можно ловить bad_alloc или вызывать set_new_handler
32. set_new_handler() вызывается, пока память не будет освобождена или программа не завершена
33. Можно для каждого конкретного класса реализовать свой обработчик set_new_handler() в виде статического члена
34. Можно создать класс-примесь (mixture) чтобы наследовать от него оператор и обработчик new
35. Применение set_new_handler удобнее, чем обрамление кода блоками try. Он работает со всеми формами new.
36. operator new() наследуется производными классами
37. Также реализуйте родственный operator new[]()
38. Нормальная форма new() обязательно должна быть перегружена (т.к. "не нормальные" ее скрывают)
39. Когда известны все возможные размеры объектов, можно создать для каждого из них пул памяти
	Его удобно реализовать классом
* delete[] в отличие от delete выделяет память на 4 байта ранее для хранения информации о количестве объектов
  это важно в случае нетривиального деструктора (см. пример с падением)
* всякий раз, когда это возможно, пользуйтесь forward declaration в хедере - это уменьшает время компиляции
* downcasting безопаснее делать при помощи dynamic_cast
* функция clone() является разновидностью виртуального конструктора
* new/delete pointer should be compared to zero
// A default constructor may have parameters that have default values.
* static members COULD be changed in const methods
* use "lazy evaluation" of not all of result dataset could be used
* use "pre-evaluation" is results could be used too often
* use ref-count and copy-on-write on big datasets in concurrent environment

Проектируя класс, следует ответить на следующие вопросы
Как следует создавать и удалять объекты?
Отличается ли инициализация от присвоения?
Что означает передача по значению?
Допустимые значения?
Допустимые преобразования?
Место в иерархии
Какие стандартные операторы?
Кто должен иметь доступ? Друзья?
Насколько новый тип общий?

Я просто подчеркнул разницу между оператором new и выражением new. Их регулярно путают

Мейерс 2-27
Как гарантированно разместить в куче?
* Закрыть конструкторы, выделять "виртуальным конструктором"

Как запретить создание в куче?
* закрыть operator new/new[] для класса

Как определить, создан ли объект в куче?
* стек обычно растет сверху вниз, куча - снизу вверх. Не учитывает статической памяти,
  которая ниже кучи
* отслеживать выделение памяти в operator new (не подойдет для new[])
  При этом в delete() нужно приводить указатель оператором dynamic_cast<const void*>,
  чтобы покрыть случаи множественных базовых классов

Мейерс 2-32 Программируйте, заглядывая в будущее
* Выражайте ограничения в коде, а не в документации
* Функция вируальна по умолчанию, невиртуальна по требованию
* Запрещайте копирование-присвоение если не имеет смысла
* операторы должны иметь естественный синтаксис
* старайтесь создавать переносимый код
* инкапсулируйте данные и по возможности методы
* избегайте прямого RTTI
* базовый класс должен иметь виртуальный деструктор
* создавайте полные классы, даже если нужна только его часть
* ограничивайте интерфейсы так, чтобы было сложно допустить ошибку
* алгоритмы имеет смысл делать обобщенными
* нетерминальные классы должны быть абстрактными
  (во избежание срезки при присвоении)
* в абстрактном классе можно и имеет смысл закрыть присвоение
  (как protected)
* абстрактные деструкторы должны быть реализованы, т.к.вызываются всегда
* абстрактный класс не должен иметь данных
* не получается создать хороший абстрактный класс, пока не известна абстракция
  (т.е. если нужно обрабатывать один тип, не нужно торопиться обобщать его)

Мейерс 2-33 Совместимость C/C++
* В C++ есть коррекция имен (на ее основе поддерживается перегрузка)
* extern "C" отключает корректироваку
* В С main является реальной точкой входа, и не поддерживает вызов статических конструкторов
* совместимость структур - в C нет методов и статических членов

