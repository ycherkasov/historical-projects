/** @brief 
Глава 3 Страуструпа
Вывод, ввод, контейнеры, алгоритмы, математические вычисления
*/

/*
Советы:
1.	Для ввода и вывода можно использовать istream_iterator и ostream_iterator.
2.	Файлы можно читать через ifstream.
3.	Конструктор итератора ввода по умолчанию создает указатель на конец ввода.
4.	Не изобретайте колесо - пользуйтесь библиотеками.
5.	Разберитесь, что делают ваши библиотеки, как деалют и какова цена их использования.
6.	Перехватывайте типичные исключения в функции main()
*/

/*Вопросы (общие)
1. Как работать со стандартом?
2. Зачем for_each() возвращает указатель на функцию?
*/

/*
общие рекомендации от Стива:
	стараться использовать виртуальные функции и полиморфизм в целом вместо "if" и "case"
	стараться использовать алгоритмы STL/Boost и функторы вместо циклов
	использовать только "умные" указатели при работе с динамической памятью
	не использовать классические массивы, а контейнеры STL (так как, например, 
	std::vector гарантирует линейное размещение элементов, то можно смешивать "старый" код, 
	работающий с указателями, с использованием контейнеров)

	тщательно продумывать операции копирования сложных классов 
	(лучше всего реализовать конструктор копирования и метод swap, 
	а оператор присваивания реализовать через них)

	всегда объявлять в коде класса конструктор копирования и оператор присваивания,
	и даже если они не используются, то просто закомментировать их объявление
	с пояснением, почему они не нужны

	никогда не использовать приведения типов в стиле С, только С++ (static_cast, const_cast и т.д.),
	так как они длинные, их нудно набивать и они уродуют вид программы - 
	в общем, все, что нужно для минимизации их наличия

	помнить, что наследование - это re-use интерфейсов, а не кода как такового
	не слишком верить компилятору ;-) (Стив их писал и знает, что они могут и подставить)
*/
