Совместимость C и C++

у C и C++ есть общее подмножество, но C++ не поддерживает весь сишный синтаксис. 
причем довольно важные его куски. сразу вспоминаются variable-sized arrays и designated initializers

http://en.wikipedia.org/wiki/Compatibility_of_C_and_C%2B%2B
* C allows a void* pointer to be assigned to any pointer type without a cast
int *j = malloc(sizeof(int) * 5);

* C++ prohibit using goto or switch jumping over an initialization
void fn(void)
{
  goto flack;
  int i = 1;
flack:
  return;
}

С/C++ difference

* C does not allow a given typedef to be duplicated in the same scope, whereas C++ allows repeated typedef
* enum values are always of type int in C, whereas they are distinct types in C++ and may have a size different from that of int
* C++ also changes some C standard library functions to add additional functions with const qualifiers
* in C++, a nested struct is defined only within the scope/namespace of the outer struct
* Non-prototype ("K&R"-style) function declarations are not allowed in C++
* In C, a function prototype without arguments, e.g. int foo(), implies that the parameters are unspecified
* C++ is more strict than C about pointer assignments that discard a const qualifier
* C++ allows to use const variable in case: operator, C doesn't
* character literals such as 'a' are of type int in C and of type char in C++
* C++ implicitly treats any const global as file scope unless it is explicitly declared extern, 
  unlike C in which extern is the default
* In C++, an object declaration is also a definition unless it contains an extern specifier and no initializer
* Conversely, inline functions in C are of file scope whereas they have external linkage by default in C++
* C requiring struct in front of structure tags (and so sizeof(T) refers to the variable), but C++ allowing it to be omitted

extern int T;
int size(void)
{
    struct T {  int i;  int j;  };
 
    return sizeof(T);
    /* C:   return sizeof(int)
     * C++: return sizeof(struct T)
     */
}

* in C99, a new keyword, _Bool, is introduced as the new boolean type
* C compilers do not name mangle symbols in the way that C++ compilers do
* C can recursively call main()
  C++ 5.2.2/9
  Recursive calls are permitted, except to the function named main (3.6.1).
* Макросы с переменным числом аргументов (параметр __VA_ARGS__).
* Можно использовать прагмы в макроподстановках (_Pragma)
* Встроенные типы _Complex и _Imaginary
* Квалификатор restrict - дает знать компилятору, что указатель на этот блок памяти только один
* Вызывать функцию, которая не была до этого декларирована
* массивы переменного размера
void function(int size)
{
   char a[size];
}
