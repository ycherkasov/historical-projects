Глава 3 Страуструпа
Вывод, ввод, контейнеры, алгоритмы, математические вычисления
Советы:
1.	Для ввода и вывода можно использовать istream_iterator и ostream_iterator.
2.	Файлы можно читать через ifstream.
3.	Конструктор итератора ввода по умолчанию создает указатель на конец ввода.
4.	Не изобретайте колесо - пользуйтесь библиотеками.
5.	Разберитесь, что делают ваши библиотеки, как деалют и какова цена их использования.
6.	Перехватывайте типичные исключения в функции main()

Вопросы (общие)



общие рекомендации от Стива:
	стараться использовать виртуальные функции и полиморфизм в целом вместо "if" и "case"
	стараться использовать алгоритмы STL/Boost и функторы вместо циклов
	использовать только "умные" указатели при работе с динамической памятью
	не использовать классические массивы, а контейнеры STL (так как, например, 
	std::vector гарантирует линейное размещение элементов, то можно смешивать "старый" код, 
	работающий с указателями, с использованием контейнеров)

	тщательно продумывать операции копирования сложных классов 
	(лучше всего реализовать конструктор копирования и метод swap, 
	а оператор присваивания реализовать через них)

	всегда объявлять в коде класса конструктор копирования и оператор присваивания,
	и даже если они не используются, то просто закомментировать их объявление
	с пояснением, почему они не нужны

	никогда не использовать приведения типов в стиле С, только С++ (static_cast, const_cast и т.д.),
	так как они длинные, их нудно набивать и они уродуют вид программы - 
	в общем, все, что нужно для минимизации их наличия

	помнить, что наследование - это re-use интерфейсов, а не кода как такового
	не слишком верить компилятору ;-) (Стив их писал и знает, что они могут и подставить)

// TODO

Опять 25 и споры про нормальный дебагер против логов.
Влад2 уже писал (вроде в той ветке), что дебагер — это особый вид логов(имеющий свои + и -),с чем я полностью согласен.

Если опустить return
Flowing off the end of a function is equivalent to a return with no value; 
this results in undefined behavior in a value-returning function.

Сравнение указателей:
template<typename T> bool less( const T* p1, const T* p2 ) { 
   return p1 < p2; 
}
Пункт стандарта не скажу по памяти, но акцентируется разница между сравнением на == или != и сравнением на < >. 
Сравнение на == != разрешено в любом случае, а на больше/меньше только в одном массиве, 
в противном случае — unspecified behavior (не undefined).

Так что, если хочется корректности, то нужно пользоваться теми средствами, для которых гарантии даны — т.е. писать
template<class T> bool less(T* a, T* b) { return std::less<T*>()(a,b); }

А заодно — (вымышленный) пример реализации, которая может этим зазором воспользоваться на вред юзеру.
Сегментная модель памяти, указатель представляет пару (селектор,смещение). 
Ну хотя бы large модель для 16-битного режима x86.
Делается допущение, что каждый объект и каждый массив расположены в пределах одного сегмента, 
поэтому для сравнения указателей (на неравенство) достаточно сравнить смещения.


Вот тебе еще пример: сколько звездочек выведет программа?

#include <stdio.h>

struct A { 
  A(...) {
    printf("*");
  }
};

int main()
{
   A three(666, 666, 666);
   A two(666, 666);
   A one(666);
   A zero();
}

Тут ведь главная замануха-то в чем: выражение A zero(); не создает переменную с именем zero, 
а объявляет функцию с именем zero и результатом типа A

Когда вообще встречается конструкция T& ref = fun(); если не считать глупостей?
— ожидается, что fun() возвращает ссылку, живущую достаточно долго (например, some_container.front())
— ad-hoc-полиморфизм (т.е. мы хотим создать автоматический объект, но не можем явно указать его тип)


/*
print("%08x\n", 42);
cout << setw(8) << setfill('0') << hex << 42 << endl;
This is the correct answer.  
The field width is set to 8, padding is set to the character 0 
and the output for integers is set to hexadecimal.  
This is the exact equivalent of the "%08x" format specification in the "printf()" C library function.
*/

/*
cin >> line1;
getline(cin, line2);
cout << "EOF\n";

It will print out: 
Line 1: Hello 
Line 2:  world! 
EOF
This is the correct answer.  
Although std::skipws is issued in the stream, 
std::getline() bypasses that mechanism, 
and the space that terminated the extraction will be read in.  
In addition, std::getline() never keeps the terminating newline in the destination string.
*/
