Глава 12 Страуструпа
Глава 9 Лаптева
Мейерс 1 Глава 6
Производные классы. Иерархия классов. 
Наследование реализации.
Виртуальные функции. Абстрактные классы. 
Проектирование иерархий классов.


Вопросы


Сделать:
1. Пример из Страуструпа с защищенным наследованием( стр. 363 )
2. Примеры со счетчиком ссылок (Мейерс 2-29)


// Абстрактные классы широко применяются в паттернах проектирования и технологии COM.

// Принцип подстановки Лисков:
// Основная идея такова: функция, использующая ссылку или указатель на базовый класс 
// должна уметь работать и с классами-наследниками, без их распознавания.
// http://old.softerra.ru/review/program/15958/page1.html
// http://forums.realcoding.net/index.php?showtopic=16693


Консистентность, в данном случае, означает соответствие значений всех переменных объекта его состоянию. 
Например, объект-строка имеет две переменные: указатель блока памяти и длину строки. 
Присваивая объекту более длинную строку, мы должны освободить старый блок памяти, выделить новый, 
скопировать строку, изменить значение указателя и значение длины. Перед выполнением первой 
из этих операций, данные объекта консистентны, после выполнения последней — тоже. 
Между первой и последней операциями, консистентность нарушена.

Правило 1: При возврате из любого public метода, данные объекта должны быть консистентны.
Правило 2: Перед выполнением исходящего вызова следует обеспечить консистентность данных объекта.
Правило 3: Необходимо учитывать, что, за время исходящего вызова, состояние объекта может быть изменено.

	In order to control these types of conversions between classes, 
	we have four specific casting operators: 
	dynamic_cast, reinterpret_cast, static_cast and const_cast. 
	Their format is to follow the new type enclosed between angle-brackets (<>) and immediately after, 
	the expression to be converted between parentheses.

	dynamic_cast <new_type> (expression)
	reinterpret_cast <new_type> (expression)
	static_cast <new_type> (expression)
	const_cast <new_type> (expression)

	The traditional type-casting equivalents to these expressions would be:

	(new_type) expression
	new_type (expression)

	static_cast can perform conversions between pointers to related classes, 
	not only upcasts (from pointer-to-derived to pointer-to-base), 
	but also downcasts (from pointer-to-base to pointer-to-derived). 
	No checks are performed during runtime to guarantee that the object being converted 
	is in fact a full object of the destination type. 
	Therefore, it is up to the programmer to ensure that the conversion is safe. 
	On the other side, it does not incur the overhead of the type-safety checks of dynamic_cast.

	dynamic_cast can only be used with pointers and references to classes (or with void*). 
	Its purpose is to ensure that the result of the type conversion points to a valid 
	complete object of the destination pointer type.
	This naturally includes pointer upcast (converting from pointer-to-derived to pointer-to-base), 
	in the same way as allowed as an implicit conversion.
	But dynamic_cast can also downcast (convert from pointer-to-base to pointer-to-derived) 
	polymorphic classes (those with virtual members) if -and only if- 
	the pointed object is a valid complete object of the target type.


	reinterpret_cast converts any pointer type to any other pointer type, even of unrelated classes. 
	The operation result is a simple binary copy of the value from one pointer to the other. 
	All pointer conversions are allowed: neither the content pointed nor the pointer type itself is checked.

	This type of casting manipulates the constness of the object pointed by a pointer,



Советы:
1. Не используйте поля хранящие информацию о типе.
2. Не передавайте объекты по значению во избежание срезки.
3. Переопределяйте конструктор повышающего преобразования для того же 
    (явно вызывая метод или конструктор родительского класса в функциональной форме).
4. Пользуйтесь абстрактными классами для 
   - определения интерфейса
   - установления контракта
   - реализации по умолчанию
5. В виртуальных классах стоит иметь виртуальный деструктор.
6. Абстрактный класс обычно не нуждается в конструкторе
7. Общепринятая практика - наследовать классы от классов (т.е. структуры в наследовании не участвуют)
8. Конструктор не наследуется - он создается по умолчанию или реализуется явно
9. Также не наследуются операторы присваивания и дружественные функции
10.Деструкторы вызываются в порядке, обратном конструктору, и не наследуются
11.Добавляемые поля могут совпадать по имени с полями базового
12.Хотя так делать не рекомендуется (в этом случае базовый член класса замещается производным)
13.В производном списке инициализации нельзя инициализировать члены базовых классов, но можно в теле конструктора
14.Методы базового класса можно вызывать явно.
15.Пользуйтеся закрытым или защищенным наследованием для сокрытия интерфейса базового класса (паттерн Адаптер)
16.Для этого же можно пользоваться агрегированием (композицией)
17.Иерархия классов может быть нециклическим графом. Глубина иерархии ничем не ограничена.
18.В базовом классе необходимо хранить только _самые_ общие данные во избежание дополнительных зависимостей
19.В производных классах виртуальные функции реализуются только если в этом есть необходимость
20.Можно объявить и определить чисто виртуальный деструктор. Он будет нормально вызываться и не наследоваться.
   Т.е. класс-наследник абстрактным не является. (он будет играть роль деструктора по умолчанию)
21.В абстрактном классе можно реализовать не чисто виртуальные методы и вызывать их для производных классов.
22.Можно "виртуализировать" внешние функции (например друзья) путем передачи ссылки 
   на базовый класс с виртуальностью.
23.Можно указывать using::f, чтобы переопределить родительский метод вместо собственного в классе
24.Значения по умолчанию в списке параметров виртуальной функции наследуются!
25.Возвращаемое значение виртуальной функции в разных классах может отличаться, если это:
  - указатель или ссылка
  - они приводятся друг к другу
26. Операторы могут быть виртуальными.
27. Формат VTBL определяется ABI.
28. В конструкторе или деструкторе вызываются только свои виртуальные методы.
29.В случае закрытого наследование также не работает приведение по ссылку-указателю к базовому классу.
30.Для реализации адаптера предпочитайте композицию. Используйте наследование, только когда обязаны так сделать.
   (доступ к защищенным членам, виртуальность)
