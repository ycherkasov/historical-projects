#pragma once

// В этом хедере рассматриваются вопросы конструирования и разрушения
// классов различными способами
// 1. Именованный автоматический объект(по умолчанию, копия).
// 2. Объект в свободной памяти (new/delete).
// 3. Нестатический объект-член класса.
// 4. Объект - элемент массива.
// 5. Локальный статический объект.
// 6. Глобальный объект.
// 7. Временный объект.
// 8. Объект, сконструированный пользовательским аллокатором.
// 9. Член объединения (union)

// Отличия конструктора от метода - конструктор не м.б. виртуальным или статическим,
// не возвращает результата

/** @brief 
Это простой класс
*/
struct intern{
	int a;
	intern();
	intern(int);
	~intern();
};

/** @brief  
Это класс, содержащий в себе другой класс
*/
class construct
{
public:
	// Конструктор по умолчанию неявно вызывает 
	// конструкторы по умолчанию агрегированных классов
	construct();

	// Но лучше делать как следующий конструктор без комментария
	construct(int i/* = 0*/);
	construct( const construct& c );
	~construct();

	// Для работы со статическими членами необходимы статические методы
	// (см. использование в .cpp)
	static void out_static_array();

private:
	intern intrn;
	int b;
	// Можно объявлять поле-массив 
	// (хотя использование массивов-членов не очень хорошо отражено в Стандарте)
	// Это вызывает проблемы с инициализацией
	int arr[5]; 
	// Данный массив может быть только обнулен как обычно обнуляют указатели - ()
	// Это даже породит warning C4351.

	// Нельзя задать количество элементов другим нестатическим членом класса.
	// Даже константным - int arr1[sz];

	// Все это делает константные массивы-члены практически бесполезными
	// Выходом является использование статических константных массивов,
	// инициализируемых вне класса
	static const char ch_array[];
	static const int int_array[];
	
	// Самое распространенное применение статических членов - счетчик объектов
	static int _counter;
};

/** @brief  
Это класс с запрещением копирования */
class noncopyble{
private:
	int d;
	noncopyble(const noncopyble& n);
	noncopyble& operator=(const noncopyble& n);
public:
	noncopyble() : d(5) {  /*d = 5; - так лучше не делать*/ }
};

/** @brief 
Функция демонстрирующая конструирование локальных статических членов */
void create_static(int i);

/** @brief 
Функция демонстрирующая конструирование  и возврат в программу
простых локальных статических членов */
int& return_static();

/** @brief 
Класс, содержащий указатель. Указатель может быть поинициализирован прямо в списке инициализации
*/
class contain_pointer{
	construct* _pc;

	// Можно содержать даже указатель на себя
	// и проинициализировать его! Но нужно аккуратнее с рекурсией.
	contain_pointer* _p_cp;

	// Параметр по умолчанию может также содержать инициализацию указателя
	// или любую другую функцию
	contain_pointer( construct* pc = new construct ) : _pc(){}
	~contain_pointer(){ delete _pc; }
};
