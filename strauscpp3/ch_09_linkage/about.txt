Глава 9 Страуструпа
Компоновка. Внешние объявления.
Компоновка в стиле C. Компоновка и указатели на функцию.
One definition rule. Стражи включения.
Глобальные переменные. Выход из программы.

Вопросы:
1. extarnal & internal linkage и видимость из других модулей


Linkage types
1. Internal linkage, in which case they refer only to program elements inside their own translation units; 
they are not shared with other translation units.
The same name in another translation unit may refer to a different object or a different class.

// The static keyword ensures internal linkage.
static int i;   

2. External linkage, in which case they can refer to program elements 
in any translation unit in the program — the program element is shared among the translation units.

namespace{
	int i;
}
// "i" has external linkage.
// This is correct.  Even though "i" is not visible outside the compilation unit, 
// it still has external linkage (C++ Standard 7.3.1.1/1 - See footnote).

3. No linkage, in which case they refer to unique entities. 
The same name in another scope may not refer to the same object. An example is an enumeration. 

C supports four different kinds of scope: 
file scope, block scope, function prototype scope, and function scope. 
C++ generalizes file scope into namespace scope, and adds class scope.

A name’s linkage affects whether two or more declarations for that name are valid, 
and if so, whether they refer to the same entity (such as a function or an object). 
Understanding linkage clears up a number of misconceptions about the behavior of C and C++ programs.

Советы.
1. Избегайте определний функций в хедерах.
2. Используйте #include только в глобальной области видимости.
3. Пользуйтесь стражами включения или #pragma once
   ODR - определения, встречающиеся в разных единицах трансляции
   д.б. идентичны лексема за лексемой.
4. Создавайте самодостаточные заголовочные файлы.
5. Глобальным переменным предпочитайте функции возвращающие статические или синглтоны.
   Нет гарантированного порядка инициализации глобальных переменных в разных единицах трансляции.
6. Пользуйтесь соглашением по компоновке extern "C" для межъязыкового взаимодействия.
7. Используйте при этом макрос #ifdef __cplusplus.
8. При передаче между модулями указателей на функции также пользуйтесь extern "C".
9. При объявлении мелких структур и множества POD-типов объединяйте их 
   в один h-файл для предотвращения путаницы и ускорения компиляции.
10.При аварийном завершении программы предпочитайте exit(), а не abort() - 
    он хотя бы вызовет деструкторы.
11. Согласно стандарту, как старому, так и новому, если переменная объявлена с модификатором const
    и при этом явно не объявлена как extern, то она получает внутренне связывание (т.е. static)

