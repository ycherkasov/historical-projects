#pragma once
#include <new>

// В этом хедере демонстрируется создание объекта 
// при помощи пользовательского аллокатора

// Мейерс 1 Правило 10
// operator new() и operator delete() перегружаются обычно для повышения эффективности
// это особенно верно для приложений, размещающих много маленьких объектов

// Мейерс 1 Правило 8
// Различайте функцию и оператор new
// Функция просто выделяет память, оператор вызывает конструктор
// Функция delete() и оператор delete() соотносятся примерно так же

void show_new1();
void show_new2();
void show_new_delete(); 
void show_bad_alloc();

class user_allooc
{
public:
	user_allooc();
	~user_allooc();
	// Мейерс 1 Правило 7
	// переобпределения для класса operator new() гарантирует,
	// что для его экземпляров будет вызван именно он
	// Мейерс 1 Правило 8
	// operator new() наследуется производными классами
	// поэтому operator new() в базовом классе нужно проектировать для производных,
	// либо просто вызывать для них стандартный operator new()
	// Также реализуйте родственный operator new[]()
	void* operator new(size_t s);

	// Без виртуальных деструкторов функция operator delete() может работать ненадлежащим образом
	void operator delete(void* p);

	// Перегруженная форма замещающего оператора new
	// Мейерс 1 Правило 9
	// Если перегружена какая-либо другая форма new, кроме нормальной
	// (замещающая, с указателем на обработчик),
	// то нормальная обязательно должна быть перегружена
	// Иначе перегруженные операторы сокроют глобальную new()
	void* operator new(size_t s, void* p);
	void operator delete(void* p, size_t s);

	// Форма new с замещением new_handler
	void* operator new(size_t s, new_handler p);

	// Можно для каждого конкретного класса реализовать свой обработчик set_new_handler()
	// Можно создать класс-примесь (mixture) чтобы наследовать от него оператор и обработчик new
};

// Класс-пул памяти
class memory_pool{
public:
	memory_pool(size_t n);
	void* alloc(size_t n);
	void free(void* p, size_t n);
	~memory_pool();
};

