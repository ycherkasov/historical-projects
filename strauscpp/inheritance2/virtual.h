#pragma once
#include <iostream>
using std::cout;
using namespace std;

// Пример с классами без виртуальных функций 
// - выполняется только раннее (статическое) связывание
struct Base {
protected:
	int func(int i){ return 2*i; }
public:

	// из этой функции базового класса вызывается защищенная функция
	// по-разному определенная в базовом и производном классе
	int call_protected_function(int i){ return func(i) + 1; }
};

struct Derived : public Base {
protected:
	// В случае раннего, статического связывания
	// эта функция никогда не будет вызвана
	virtual int func(int i){ return i*i; }
};

struct Base_virt {
protected:
	// Объявим функцию виртуальной. Класс станет полиморфным.
	// Функция и виртуальность станут наследоваться,
	// т.е. все производные классы будут полиморфными.
	virtual int func(int i){ return 2*i; }
public:
	int call_protected_function(int i){ return func(i) + 1; }
};

struct Derived_virt : public Base_virt {
protected:
	// В случае позднего, динамического связывания
	// эта функция будет вызвана для экземпляра класса Derived_virt
	virtual int func(int i){ return i*i; }
};

/*
1. Конструкторы и статические ф-ции не могут быть виртуальными.
2. Прототипы наследуемых виртуальных функций должны совпадать.
3. Если прототип отличается списком параметров, функция теряет виртуальность.
4. Если прототип отличается константностью или возвращаемым значением, 
происходит ошибка компиляции.
5. Виртуальную функцию можно вызвать невиртуально, по спецификатору.
6. Затраты на виртуальность - размер указателя, инициализация vtbl и косвенный вызов.
*/

struct A_virt {

	
	A_virt();
	virtual ~A_virt();
	
	/**	Выполняем функцию f на создании и разрушении класса
		Функция f виртуальна, следовательно не рекомендована к использованию из
		конструкторов-деструкторов (хотя и не запрещена) */
	virtual ostream& f() const;
	// Наблюдаем, что в конструкторах и деструкторах работает статическое связывание

	//virtual A& operator+=(A_virt& a);
};

/** То же самое для B_virt */
struct B_virt : public A_virt{

	B_virt();
	virtual ~B_virt();
	/**Выполняем функцию f на создании и разрушении класса*/
	virtual ostream& f() const;
};

// Прием искуственной виртуализации внешней функции
// Передаем в нее параметром ссылку на базовый класс
// В резальтате виртуализация работает во внешнней функции
inline ostream& operator<<( ostream& t, A_virt& c ){
	return c.f();
}

// Виртуальный деструктор широко используется для полиморфной очистки
// Деструктор может быть чисто виртуальным, но его чистая виртуальность
// отличается от остальных методов (см. пример)

struct v_base{
	v_base();
	// Создадим чисто виртуальный деструктор
	virtual ~v_base() = 0;
	// чисто виртуальный деструктор может иметь определение!
	// Более того, чтосто виртуальные методы тоже могут иметь определение 
	// и вызываться в производных классах! 
	void pure();
	// Это может понадобиться в целях форммирования общего наследуемого кода.
	// Это называется "наследование реализации по умолчанию" (Мейерс)
};

struct v_derived : public v_base {
	v_derived();
	// Не будем реализовать деструктор в производном классе
	// По идее, он должен быть абстрактным
	//~v_derived();
	// Но деструкторы не наследуются, так что абстрактность тоже не наследуется
};