Возможные оптимизации C++

Простые:
- подстановка (вычисленных) констант в вызов
- инлайнинг
- удаление проверок когда всегда true/false 
  (иногда довольно сложных, типа проверка vector::size() OOR если явно не выйдем за пределы)
- if-else выключает многие оптимизации!
- упреждающее чтение массива в регистры (+ за последовательную обработку)
- switch последовательно
- компилятор использует "раскраску графа" для нахождения пересечений области видимости переменных

Циклы:
- убирает лишние переменные в цикле, явно зависящие только от счетчика (расщепление)
- векторизация (MMX,SSE)
- развертывание или частичное развертывание цикла(5 по 2 вместо 10) - чтобы более интенсивно использовать кэш команд CPU
- вынесение неизменных вычислений из цикла (вынесение инварианта)
- если в (0..n) части цикла выполняются одни действие, а (n+1, m)- другие, 
  то разбивается на 2 цикла (размыкание цикла) - чаще включает векторизацию
- Многие компиляторы имеют собственный байт-код для оптимизаций
  (пример - реализация устройства Даффа)
- SSA (Static Single Assignment) - внесение в маскируемое имя переменной дополнительной информации 
  (каждое привсаивание -> новое имя, уменьшает количество присвоений, неиспользуемые переменные)

не забываем про ключи компилятора
gcc: -march - будет работать только на конкретной архитектуре
     -mtune - будет оптимизировано под архитектуру

Некоторые компиляторы распознают и оптимизируют шаблоны проектирования, перемножение матриц и тп
