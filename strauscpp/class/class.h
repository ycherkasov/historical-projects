#pragma once
#include <string>

// В данном хедере рассматривается структура типового класса
// с обычными, константными и статическими членами
// константными и обычными методами
// Методы снятия констанности, спецификатор mutable

class A{

public:

	// Т.к. класс содержит константные члены
	// Конструктор по умолчанию не может быть вызван
	//A(); (то же для ссылок)

	A() : a1(10), a5(0), a8(0), cp1(0){}
	
	// Для инициализации нулем может быть применена форма записи ()
	A(int a) : a1(a), a5(), a8(), cp1(){}
	A(int, int, int);
	
	int get_int1() const;
	int get_int6() const;
	
	void set_a5(int);

	void set_a6_mutable(int) const;

// Имеет смысл помещать приватные данные в конце, 
// чтобы сделать акцент на открытых данных интерфейса
// в этом случае инлайновые методы стоит размещать 
// за пределами объявления класса в том же хедере
private:
	const int a1; // константное поле, д.б. инициализировано в конструкторе
	static const int a2 = 10; // константное статическое поле м.б. иниц. в объявлении
	static const int a3;       // д.б. иниц. в cpp
	static const double a4;    // д.б. иниц. в cpp
	

	int a5;
	// Неконстантные статические члены
	static int a6;
	static double a7;

	// !!! В качестве констант также удобно использовать 
	// члены неименованных перечислений
	enum{ c1 = 5, c2 = 7, c3 = 12 };

	// Если член объявлен mutable, то он изменим всегда
	// даже являясь членом статического объекта
	mutable int a8;

	// константность указателей
	char *const cp1; // константный указатель
	char const* cp2; // указатель на константу
	const char* cp3; // указатель на константу

	// Существует мнемоническое правило, позволяющее легко запомнить, 
	// к чему относится const. Надо провести черту через "*", если const слева, 
	// то оно относится к значению данных; если справа - к значению указателя.
	
	// Можно также читать объявление "справа налево" - 
	// char *const cp1 - константный указатель на char
	// char const* cp2 - указатель на константный char
	// const char* cp3 - указатель на char константный
};


// Константный метод - ничего не меняет в классе
// Может быть вызван как для константного, так и для неконстантного экземпляра.
inline int A::get_int1() const	
{ return a1; }

inline int A::get_int6() const	
{ return a6; }


// Неконстантный метод - может быть вызван только
// для неконстантного экземпляра класса
inline void A::set_a5(int i)	
{ a5 = i; }

// Константный метод, изменяющий mutable-член
// может быть вызван для константного экземпляра
inline void A::set_a6_mutable(int i)const
{ a8 = i; }


// Классы имеет смысл замещать структурами,
// если они содержат немного данных, или просто композицию данных, 
// а не представление реального объекта
struct AA{
	int a;
	int b;
};

// Близкие по смыслу классы имеет смысл помещать в пространство имен

// Типичная структура хорошего, годного класса
class good_weekday_t{

// Сначала - открытый интерфейс
public:
	
	// перечисления в начале
	enum Wday{ mon = 1, tus, wed, thr, frd, sat, sun };

	// Потом - класс исключений и другие служебные классы
	class bad_weekday_t{};

	// конструкторы
	good_weekday_t(int day = mon) : _wday(day){}
	good_weekday_t(std::string& sday){/*здесь преобразование строки в день недели*/}

	// константные методы доступа к данным
	Wday get_weekday() const;
	std::string get_weekday_str() const;

	// операторы если надо
	bool operator==(const good_weekday_t& w);
	bool operator!=(const good_weekday_t& w);
	// ... и прочие операторы

	// Функции-помощники
	bool is_weekend() const;
	int diff(const good_weekday_t& w) const;
	
	// неконстантные модификаторы
	void set_weekday(int day);

private:
	int _wday;
	std::string _string_day;
}; 
