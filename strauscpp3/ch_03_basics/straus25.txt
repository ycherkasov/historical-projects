23
* Не существует универсальных рецептов в проектровании
* Успешные примеры проектирования при бездумном копировании чаще всего не срабатывают дважды
* Хорошо спроектированные программы легко:
 - тестрировать
 - портировать
 - обслуживать
 - расширять
 - изменять
 - понимать
* Баланс между отсуствием проекта и бесконечным проектированием
* Баланс между разработчиками и проектировщиками. Невозможно полное разделение
* Важные моменты:
 - экспериментирование
 - анализ
 - тестирование
 - документирование
 - менеджмент
* модель водопада в чистом виде неэффективна
* Перед проектированием должны подбираться подходящие существующие компоненты
* Проект должен декомпозироваться на новые компоненты
* Класс не следует рассматривать в полном отрыве от компонента
* Этапы проектирования
 1.Выявление классов. 
   Существительные - сущности, глаголы - методы, прилагательные - свойства
   Несколько человек при проектировании лучше чем один
 2.Выявление операций.
   Конструирование, копирование, уничтожение
   Минимальный набор операций - реализовать
   Возможный набор полезных операций - реализовать только самые важные
   Выделение потенциально общих операций
   Виды операций
   - основные
   - немодифицирующие
   - модифицирующие
   - порождающие
   - итерирующие
 3.Взаимосвязи - наследование, использование, параметризация
 4.Выделение минимального и полного интерфейса
 5.Вынесение общей функциональности в родителей, хелперы, параметры
 6.Изучить существующие примеры систем. Намного проще, чем все проектировать с нуля.
* Создать прототип и вовремя от него избавиться
* Возможные виды прототипов - интерфейсы без реализации
* Тестировать нужно начинать сразу
* Поощрять повторное использование
* Оценивать, стоит ли повторное использование сил на его поддержку (общие компоненты очень затратны и сложны)
* Иметь стандарты (кодирования, документирования, бизнес-процессов), но не в ущерб здравому смыслу
* Новинки внедрять поэтапно
* Необходимо руководство для новых разработчиков

24
* При проектировании необходимо фокусироваться на классах(концепциях), а не на функциях(действиях)
* Реализация программы на "бедном" языке приводит к тому, что программа не отражает реальные объекты, а код становится раздутым
* Типы отношений классов
   - наследование
   - включние
   - использование
* Виды классов по уровню выражения реальных объектов
   - классы, отражающие прикладные понятия
   - классы, являющиеся артефактами реализации (хелперы и тп)
* Более подробная иерархия
  - Уровень бизнес-логики
    - Абстрактные обобщенные понятия
    - Конкретные понятия
  - Аппаратный уровень
    - классы аппаратных ресурсов (память, видео и тп)
    - Классы системных ресурсов (мьютексы, потоки, хэндлы)
  - Языковой уровень
    - Классы, композирующие конкретные классы (контейнеры, итераторы)
    - встроенные типы и управляющие структуры
* Следует избегать слишьком активного разрастания иерархии (для всего - отдельный тип)
* Для выбора отношений is и has нужно понять, является ли реальный объект родительским или использует его
* для is используйте наследование всегда, когда только можно. Для has - когда без него не обойтись
* Интерфейс и реализация должны быть максимально независимы
* Состояния класса должны поддерживать четко определенные инварианты
* Перед и после выполнения имеет смысл проверять пред- и пост-условия
* assert (dynamic && static)
* статические проверки где можно
* итерация предпочтительнее рекурсии
* Компонент должет быть представлен для пользователя набором конкретных и задокументированных интерфейсов
* Когда переопределяется поведение, нужно использовать виртуальность, когда типы - шаблоны
* Также шаблоны подойдут, когда объекты не укладываются в одну иерархию
* Избегайте жирных интерфейсов
 
25
* Абстрактные типы - выражение интерфейса (IVehicle). Не содержат реализации
* Узловые типы - абстрактны, но содержат реализацию (Emergency). Могут расширять абстрактые
* Конкретные типы - Вырыжение конкретных понятий(vector, Date, Car). Не абстрактные. 
  Не предназначены для наследования (но могут быть хороши для композиции)
  Могут не участвовать в наследовании вовсе или не иметь виртуальных методов.
* Типы действия - акторы, функторы. Паттерн команда. Предикаты, параметры шаблонов.
* Вспомогательные типы - хелперы, прокси и т.п. Как правило, не предназначены для наследования.
* Возможны гибридные типы, но их следует по возможности избегать


