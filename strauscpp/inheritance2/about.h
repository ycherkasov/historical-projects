/* Глава 12 Страуструпа
Производные классы. Иерархия классов. 
Наследование реализации.
Виртуальные функции. Абстрактные классы. 
Проектирование иерархий классов.
*/

/*Вопросы
*/

/** Сделать:
1. Пример из Страуструпа с защищенным наследованием( стр. 363 )
*/

// Абстрактные классы широко применяются в паттернах проектирования и технологии COM.

// Принцип подстановки Лисков:
// Основная идея такова: функция, использующая ссылку или указатель на базовый класс 
// должна уметь работать и с классами-наследниками, без их распознавания.
// http://old.softerra.ru/review/program/15958/page1.html
// http://forums.realcoding.net/index.php?showtopic=16693

/*
Консистентность, в данном случае, означает соответствие значений всех переменных объекта его состоянию. 
Например, объект-строка имеет две переменные: указатель блока памяти и длину строки. 
Присваивая объекту более длинную строку, мы должны освободить старый блок памяти, выделить новый, 
скопировать строку, изменить значение указателя и значение длины. Перед выполнением первой 
из этих операций, данные объекта консистентны, после выполнения последней — тоже. 
Между первой и последней операциями, консистентность нарушена.

Правило 1: При возврате из любого public метода, данные объекта должны быть консистентны.
Правило 2: Перед выполнением исходящего вызова следует обеспечить консистентность данных объекта.
Правило 3: Необходимо учитывать, что, за время исходящего вызова, состояние объекта может быть изменено.
*/

/*
Советы:
1. Не используйте поля хранящие информацию о типе.
2. Не передавайте объекты по значению во избежание срезки.
3. Переопределяйте конструктор повышающего преобразования для того же 
    (явно вызывая метод или конструктор родительского класса в функциональной форме).
4. Пользуйтесь абстрактными классами для 
   - определения интерфейса
   - установления контракта
   - реализации по умолчанию
5. В классах с виртуальными классами стоит иметь виртуальный деструктор.
6. Абстрактный класс обычно не нуждается в конструкторе
7. Общепринятая практика - наследовать классы от классов (т.е. структуры в наследовании не участвуют)
8. Конструктор не наследуется - он создается по умолчанию или реализуется явно
9. Также не наследуются операторы присваивания и дружественные функции
10.Деструкторы вызываются в порядке, обратном конструктору, и не наследуются
11.Добавляемые поля могут совпадать по имени с полями базового
12.Хотя так делать не рекомендуется (в этом случае базовый член класса замещается производным)
13.В производном списке инициализации нельзя инициализировать члены базовых классов, но можно в теле конструктора
14.Методы базового класса можно вызывать явно.
15.Пользуйтеся закрытым или защищенным наследованием для сокрытия интерфейса базового класса (паттерн Адаптер)
16.Для этого же можно пользоваться агрегированим (композицией)
17.Иерархия классов может быть нециклическим графом. Глубина иерархии ничем не ограничена.
18.В базовом классе необходимо хранить только _самые_ общие данные во избежание дополнительных зависимостей
19.В производных классах виртуальные функции реализуются только если в этом есть необходимость
20.Можно объявить и определить чисто виртуальный деструктор. Он будет нормально вызываться и не наследоваться.
   Т.е. класс-наследник абстрактным не является. (он будет играть роль деструктора по умолчанию)
21.В абстрактном классе можно реализовать не чисто виртуальные методы и вызывать их для производных классов.
22.Можно "виртуализировать" внешние функции (например друзья) путем передачи ссылки 
   на базовый класс с виртуальностью.
*/