#include <iostream>
#include "simple_functors.h"


using namespace std;

void foo(){
	cout << "foo" << endl;
}

// Демонстрация указателей на функции как функторов
void show_function_pointers(){
	// Функции в C++ могут вызываться прямым (direct) или непрямым (indirect) вызовом
	// Прямой быстрее, но чтобы его выполнить, необходимо знать адрес функции во время компиляции
	// Для указателей на функции, методы или виртуальных функций это зачастую невозможно
	
	// Две идентичные формы определения указетля на функцию
	typedef void foo_p2();
	typedef void (foo_p1)();

	// Указатель на функцию неявно и без предупреждений преобразуется в ссылку
	// Примерно как имя массива преобразуется в указатель
	// Это преобразование называется сведением (decay)

	foo_p1* pf = foo;

	// Две идентичных формы вызова
	pf();	// неявное преобразование (сведение)
	(*pf)();// эквивалент

	foo_p2& rf = foo;	// без неявного преобразования
	rf();

	// Во всех вариантах по умолчанию работает косвенный вызов
	// (если компилятор не соптимизирует)
	// То же для указателей на методы класса
}

// Демонстрация функторов-классов
void show_simple_predicate(){

	int a[] = {3,4,6,2,9,1,0,3,6,8};
	vector<int> v1(a, a + 10);

	// передача функтора как параметра шаблона
	custom_sort< my_less<int> >(v1);

	vector<int> v2(a, a + 10);
	// передача функтора как аргумента функции
	// Это позволяет задавать предикат во время исполнения
	my_less<int> f1;
	custom_sort(v2, f1);
	// если функтор тривиальный (не изменяет состояние, 
	// не имеет конструктора копирования и т.п.), компилятор соптимизирует
}

bool myless(int a, int b){
	return (a > b);
}

// Демонстрация обертки любой функции в объект функтора
void show_func_ptr_wrapper(){
	
	// оборачиваем функцию с 2 параметрами, возвращающую bool
	function_ptr<bool, int, int> fp(myless);
	// Для экономии места можно обернуть конструктор в функцию
	// тогда будет работать вывод аргументов
	// кроме возвращаемого значения

	int a[] = {3,4,6,2,9,1,0,3,6,8};
	vector<int> v1(a, a + 10);
	custom_sort(v1,fp);
}


int main(){
	//show_function_pointers();
	//show_simple_predicate();
	show_func_ptr_wrapper();
	return 0;
}