
Главы 4-6 Страуструпа
Типы. Интегральные типы (bool, char, int). 
Арифметические типы (интегральные + float)
wchar_t (_t - наследие от ANSI C)
Перечисления. Указатели.
Битовые операции.


TODO
1. fenv.h functions does not work on MSVC. Check it on Linux, maybe ask on the forum.
(see show_fp_coltrol() in fpoint.cpp)
2. Пример с приведением к fixed point (fpoint.cpp)


Советы:
1. Давайте переменным с большой областью видимости большие, понятные имена.
2. А с малой - короткие однобуквенные.
3. Придерживайтесь единого стиля именования.
4. Выбирайте имена, отражающие смысл, а не содержание переменной.
5. Предпочитайте архитектуронезависимые типы.
6. Избегайте беззнаковой арифметики.
7. Избегайте понижающих преобразований.
8. Избегайте нетривиальной арифметики указателей.
9. Пользуйтесь NULL для нулевого указателя, в новом стандарте - nullptr
10. Используйте константные ссылки для передачи параметров.
11. short is system dependent



void* лучше использовать на нижнем уровне. 
На верхних его использование скорее всего является ошибкой проектирования.

Порядок вычислений внутри подвыражений не определен (v[i] = i++ - UB).
Побитовые операторы применяются к интегральным типам.
Операторы - это то, что можно перегрузить. Остальное - инструкции (statements)

Aliasing is when more than one lvalue refers to the same memory location 
(when you hear lvalue, think of things (variables) that can be on the left-hand side of assignments), 
i.e. that are modifiable. As an example:

int anint = 0;
int *intptr=&anint;

Выравнивание:
struct S { char c; int i; };
bool is_equal(S a, S b) { return 0 == memcmp(&a, &b, sizeof(S)); }

Почему rand() - очень медленная функция?
Я имею в виду вызов Enter/LeavCriticalSection или что-то такого же, 
что блокирует шину данных, когда зовём rand при линковке с многопоточной библиотекой.
Если перенести этот код на многопроцессорную машину, где лок шины данных будет настоящий, а не "понарошку" - то я не знаю сколько будет. Вот код для тестирования:
#include <stdlib.h>
#include <time.h>
#include <iostream>
int main()
{
    volatile int x;
    int n = 10000000;
    clock_t t = clock();
    for (int i = 0; i < n; ++i) x = rand();
    std::cout << int(double(n) * CLOCKS_PER_SEC / (clock() - t));
}

for (int i = 0; i <= vector.size()-1; ++i)
i < -1 тут воспринимается как i < (unsigned)-1, то есть i < 0xFFFFFFFF

Приоритет операций
1	
::			Область видимости	 Слева-направо

2	
++   --		Суффиксальный/постфиксный инкремент и декремент
()			Вызов функции
[]			Обращение к массиву по индексу
.			Выбор элемента по ссылке
−>			Выбор элемента по указателю

3
++   --		Префиксный инкремент и декремент	 Справа-налево
+   −		Унарный плюс и минус
!   ~		Логическое НЕ и побитовое НЕ
(type)		Приведение к типу type
*			Indirection (разыменование)
&			Адрес
sizeof		Размер
new, new[]	Динамическое выделение памяти
delete, delete []Динамическое освобождение памяти

4
.*   ->*	Указатель на член	 Слева-направо
5	
*   /   %	Умножение, деление и остаток

6	
+   −		Сложение и вычитание

7	
<<   >>		Побитовый сдвиг влево и сдвиг вправо

8	
<   <=		For relational operators < and ≤ respectively
>   >=		For relational operators > and ≥ respectively

9
==   !=		For relational = and ≠ respectively

10
&			Побитовое И

11	
^			Побитовый XOR (исключающее или)

12	
|			Побитовое ИЛИ (inclusive or)

13	
&&			Логическое И

14	
||			Логическое ИЛИ

15	
?:			Тернарное условие	 Справа-налево
=			Прямое присваивание (предоставляемое по умолчанию для C++ классов)
+=   −=		Присвоение с суммированием и разностью
*=   /=   %=Присвоение с умножением, делением и остатком от деления
<<=   >>=	Assignment by bitwise left shift and right shift
&=   ^=   |= Assignment by bitwise AND, XOR, and OR

16	
throw		Throw оператор (выброс исключений)

17	,		Запятая	