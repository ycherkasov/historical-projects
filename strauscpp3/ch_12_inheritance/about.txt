Глава 15 Страуструпа
Глава 10 Лаптева
Иерархии классов. Множественное наследование.
Разрешение неоднозначности. using-объявления.
Виртуальное наследование. Виртуальные базовые классы.
Управление доступом. Защищенные члены. Доступ к базовым классам.
Полиморфизм, динамическое приведение, информация о типе и RTTI
"Виртуальные конструкторы"
Мультиметоды. Паттерн Посетитель.
Указатели на члены.
Свободная память. Виртуальные конструкторы.


Пример из STL - iostream : istream, ostream


Сделать:
2. Разобрастья с форматом vptr, приведением dynamic_cast (указывает на определенные vptr?) - Мейерс 30-31
3. То же с указателями на члены (виртуальными, невиртуальными)
4. Мейерс 1 Правило 26 Пример со множ.наследованием
5. примеры Мейерс 2-30,31



Советы:
1. Пользуйтесь множественным наследованием, чтобы отделить реализацию от интерфейса.
2. Избегайте явного преобразвания типа
3. Если класс определяет operator delete, необходимо определить виртуальный деструктор
4. Не вызывайте виртуальные функции из конструкторов и деструкторов (подставляются только "свои" функции)
5. Разрешайте неоднозначность при множественном наследовании (явное переопределение или using).
6. Неоднозначность можно разрешить с помощью префикса ::
7. При виртуальном наследовании конструктор базового класса вызывается послденим производным классом в иерархии.
8. Множественное наследование хорошо управлемо в случае абстрактного базового класса
9. Объявление данных защищенными свидетельствует об ошибке проектирования. Это не относится к защищенным функциям.
10.Принцип доминирования состоит в следующем:
   виртуальный метод print() унаследован от всех трех базовых классов 
   но выполнится только там, где он явно переопределен
   причем в самом "производном" классе из доступных
11.Конструкторы вызываются в порядке, прописаном при наследовании.
12.Можно использовать паттерн финализации наследования.
13.Для поввышающего или перекрестного dynamic_cast требует полиморфизма.
14.Если преобразование запрещено, то возвращаенися 0-указатель.
15.Если преобразуется в ссылку, то при неудаче бросается исключение bad_cast.
16.Используйте мультиметоды по необходимости.
17.Интерфейс и реализация по умолчанию должны быть разделены 
  (т.е. реализация чисто виртуальной функции м.б. опасна, т.к. вызывается молча)
18.Когда функция невиртуальна, предполагается, что она не будет переопределена
19.Нормально оставлять виртуальную функцию в производных классах без реализации
20.В ряде случаев логично применять dynamic_cast с проверкой на 0
21.Мейерс 1-41 Эмпирическое правило выбора между шаблоном и полиморфизмом
   Полиморфизм - когда отличается поведение. Шаблон - когда отличается хранимый тип
