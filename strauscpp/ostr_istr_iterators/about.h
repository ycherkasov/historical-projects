/** @brief 
Глава 3 Страуструпа
Вывод, ввод, контейнеры, алгоритмы, математические вычисления
*/

/*
Советы:
1.	Для ввода и вывода можно использовать istream_iterator и ostream_iterator.
2.	Файлы можно читать через ifstream.
3.	Конструктор итератора ввода по умолчанию создает указатель на конец ввода.
4.	Не изобретайте колесо - пользуйтесь библиотеками.
5.	Разберитесь, что делают ваши библиотеки, как деалют и какова цена их использования.
6.	Перехватывайте типичные исключения в функции main()
*/

/*Вопросы (общие)
*/

/*
общие рекомендации от Стива:
	стараться использовать виртуальные функции и полиморфизм в целом вместо "if" и "case"
	стараться использовать алгоритмы STL/Boost и функторы вместо циклов
	использовать только "умные" указатели при работе с динамической памятью
	не использовать классические массивы, а контейнеры STL (так как, например, 
	std::vector гарантирует линейное размещение элементов, то можно смешивать "старый" код, 
	работающий с указателями, с использованием контейнеров)

	тщательно продумывать операции копирования сложных классов 
	(лучше всего реализовать конструктор копирования и метод swap, 
	а оператор присваивания реализовать через них)

	всегда объявлять в коде класса конструктор копирования и оператор присваивания,
	и даже если они не используются, то просто закомментировать их объявление
	с пояснением, почему они не нужны

	никогда не использовать приведения типов в стиле С, только С++ (static_cast, const_cast и т.д.),
	так как они длинные, их нудно набивать и они уродуют вид программы - 
	в общем, все, что нужно для минимизации их наличия

	помнить, что наследование - это re-use интерфейсов, а не кода как такового
	не слишком верить компилятору ;-) (Стив их писал и знает, что они могут и подставить)
*/

// TODO

/*
print("%08x\n", 42);
cout << setw(8) << setfill('0') << hex << 42 << endl;
This is the correct answer.  
The field width is set to 8, padding is set to the character 0 
and the output for integers is set to hexadecimal.  
This is the exact equivalent of the "%08x" format specification in the "printf()" C library function.
*/

/*
cin >> line1;
getline(cin, line2);
cout << "EOF\n";

It will print out: 
Line 1: Hello 
Line 2:  world! 
EOF
This is the correct answer.  
Although std::skipws is issued in the stream, 
std::getline() bypasses that mechanism, 
and the space that terminated the extraction will be read in.  
In addition, std::getline() never keeps the terminating newline in the destination string.
*/
