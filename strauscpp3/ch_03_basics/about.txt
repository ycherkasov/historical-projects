Глава 3 Страуструпа
Вывод, ввод, контейнеры, алгоритмы, математические вычисления
Советы:
1.	Для ввода и вывода можно использовать istream_iterator и ostream_iterator.
2.	Файлы можно читать через ifstream.
3.	Конструктор итератора ввода по умолчанию создает указатель на конец ввода.
4.	Не изобретайте колесо - пользуйтесь библиотеками.
5.	Разберитесь, что делают ваши библиотеки, как деалют и какова цена их использования.
6.	Перехватывайте типичные исключения в функции main()

Вопросы (общие)



общие рекомендации от Стива:
	стараться использовать виртуальные функции и полиморфизм в целом вместо "if" и "case"
	стараться использовать алгоритмы STL/Boost и функторы вместо циклов
	использовать только "умные" указатели при работе с динамической памятью
	не использовать классические массивы, а контейнеры STL (так как, например, 
	std::vector гарантирует линейное размещение элементов, то можно смешивать "старый" код, 
	работающий с указателями, с использованием контейнеров)

	тщательно продумывать операции копирования сложных классов 
	(лучше всего реализовать конструктор копирования и метод swap, 
	а оператор присваивания реализовать через них)

	всегда объявлять в коде класса конструктор копирования и оператор присваивания,
	и даже если они не используются, то просто закомментировать их объявление
	с пояснением, почему они не нужны

	никогда не использовать приведения типов в стиле С, только С++ (static_cast, const_cast и т.д.),
	так как они длинные, их нудно набивать и они уродуют вид программы - 
	в общем, все, что нужно для минимизации их наличия

	помнить, что наследование - это re-use интерфейсов, а не кода как такового
	не слишком верить компилятору ;-) (Стив их писал и знает, что они могут и подставить)

// TODO


а вот кстати фрактал:

#include<stdio.h>
main(k)
{
float i,j,r,x,y=-16;while(puts(""),y++<15)
for(x=0;x++<84;putchar(" .:-;!/>)|&IH%*#"[k&15]))
for(i=k=r=0;j=r*r-i*i-2+x/25,i=2*r*i+y/10,j*j+i*i<11&&k++<111;r=j);
}



#include <stdio.h>
void SomeFunc(char par[32][64])
{
 par[0][0]='A';
}
char p[32][64];
int main()
{
 p[0][0]='X';
 SomeFunc(p);
 printf("%c\n",p[0][0]);
 return 0;
}

>в результате выдает A... мне кажется должно быть X ведь массив передается(должен) по значению.. 
>посмотрел асм код... передается указатель.. кто пояснит ? 
>и вообще выходит они что спрашивали то ? тут их все ответы опровергли уже...

все правильно, потомусто "p" является указателем на первый элемент массива и эквивалентно следущему 
p = &p[0][0]. Конечно в асме ты и увидел указатель :).


Как пример:
unsigned int i = 1;
int j = -1;

if (j < i){
    std::cout << "Unreachable." << std::endl;
}
Секция Unreachable достигается? Если нет, то почему? Мдааа...
Далее стандартно:

- Исключения в конструкторах 
- Приватный деструктор 
- Какой-нибудь алгоритм сортировки(надо будет пирамидальную сортировку вызубрить) 
- char - signed или unsigned? 
- По каким правилам компилятор выполняет неявные преобразования типов 
- Далее удивили:

class Base {
public:
  int a;
};
class Derived : private Base {
public:
  void foo(){
    a = 10;
  }
};
Такое дело позволительно? Прикол в том, что модификатор public, указываемый при наследовании, 
так прочно вбился в голову, что видеть что-то другое на его месте кажется противоестественным. 
Но, слава Богу, здравый смысл взял верх.

Реализовать функцию перестановки слов в строке. Возвращаемое значение – строка с 
переставленными словами.

Нарисовать при помоши ‘*’ треугольник вида 
    * 
   *** 
  *****



Вот простой пример - первый вопрос: 
> 1. Что будет напечатано? 
> #include <stdio.h> 
> void main() 
> { 
> char a[] = "123"; 
> printf( "%d", sizeof(a) ); 
> } 

Кровавый вопрос, честное слово.  Абсолютно кровавый.

Если интересует наличие нуль-терминатора в массиве - нужно об этом и спрашивать. 
Иначе непонятно, о каких именно проблемах хочет услышать собеседующий. 
И о нуль-терминаторе речь может совсем не зайти ;)

Сначала возникнет вопрос платформы. 
С одной стороны, спрашивают про "что будет напечатано". 
Но void main() выкидывает нас из hosted environment - там требуется int main(). 
А во freestanding environment может не быть ни printf, ни даже <stdio.h>. 
Что характерно - именно случай некоторых консолей ;) 
То есть вопрос "что будет напечатано" смысла не имеет совершенно. 
Но положим, что printf есть и соответствует стандарту. 
(Ссылки: C99 5.1.2.1/1, 5.1.2.2.1/1)

Затем возникает строковый литерал - и вопросы переносимости. 
К счастью, "123" проблем не вызывает - в отличие от "Ивана", фигурирующего во втором вопросе у sly_fox. 
Размер в байтах у "123" гарантируется байт-в-байт представимостью source character set '1', '2' и '3'. 
А вот "Иван" может смело сгенерировать multibyte представление со всеми спецэффектами. 

Скобки после sizeof для выражений не нужны (они требуются только для типов). 
Обычно рекомендуется ставить скобки всегда - чтобы не запутаться в приоритетах ;) 
Однако, конкретно в данном случае возникает интересный вопрос про array-to-pointer conversion: 
  char arr[100]; 
  sizeof arr;  // гарантированный array sizeof 
  sizeof (arr); // дефектный wording про primary expression и array-to-pointer в C ;) 
  sizeof (0, arr); // C и C++ отличаются в семантике ;) 
  sizeof (0+arr); // гарантированный array-to-pointer sizeof 
Для любителей совсем изощрённого онанизма - покопайтесь и поймите отличия! ;) 
(Ссылки: C99 6.5.3.4/3, 6.3.2.1/3, 6.5.1/5)

size_t - unsigned (т.е. "%d" уже мимо). 
А во-вторых, он не обязан быть представим в int. 
Это может быть смело long long

sizeof(int) - минимум 16 влияющих на значение бит.

Те, кто знают стандарт, часто не способны объяснить ни почему, ни зачем. 
И типично ленятся тупо прочесть хотя бы rationale или defect reports.
Типичный пык-мык у "знатоков" возникает при простом вопросе о порядке инициализации статических членов, 
если в этом замешаны шаблонные классы.

Разговор в теории мог бы идти про 
- битовую неопределенность представления int (endianness как частный случай), 
- трапы в представлении int (например, int как ненормализованной float с фиксированной экспонентой), 
- трапы в знаковых битах int, 
- разный порядок бит в char и в int, 
- трапы в знаковых битах (signed) char (as opposed to unsigned char), 
- невалидный индекс массива, предполагающий sizeof(int)>1.

http://www.gamedev.ru/code/forum/?id=15588&page=45
найти медиану последовательности N при условии что >N/2 значений в 
массиве повторяются. это все за 1 проход.

Есть 50 мудрецов, которых призвал царь. На след. утро им должны надеть шапки
(чёрные и белые(могут быть хоть все одного цвета)) и выстроить в очередь. 
Мудрец видит все шапки впереди стоящих. 
Спрашивают с конца. Если угадал цвет, то спасён, нет - голову с плечь.
Если о количестве черных или белых шапок ничего неизвестно, 
то я не могу себе представить как спасти больше 49 мудрецов.
Кстати, чуть более интересен вопрос об оптимальной стратегии тех, 
кто шапки раздает, исходя из того, что мудрецы - мудрецы.
Решение задачи
http://www.gamedev.ru/code/forum/?id=15588&page=63

49.5 максимум: 
черный пусть = 1 
белый = 0 
последний хором ссумирет всех кого видит и громно говорит(это и есть 0.5) 
ему как повезед 
каждый послед считает ксором тех кто перед ним и узнает какая у него шапочка... 
громно говорит 
остальные ксорят и получают текущую сумму...


1) i = v[i++]; //unspecified behavior 
2) i = 7, i++, i++; //i равно 9
3) i = ++i + 1; //unspecified behavior 
4) i = i + 1; //значение i увеличено на 1
В первом и третьем примерах указано "unspecified behavior", 
хотя переменная изменяется дважды и только что было сказано, что это ведет к undefined behavior.
И точно в списке багов Стандарта это место упомянуто. 
В предложении по устранению бага советуют поменять слово unspecified на слово undefined.

http://alenacpp.blogspot.ru/2005/08/unspecified-behavior-undefined.html
Большинство вещей, связанных с порядком выполнения, не является undefined behavior. 
Они обычно просто unspecified behavior - скажем, компилятор может сделать interleaving 
вычислений или например вычислять в разном порядке в разных местах программы.
Т.е. скажем printf("%d %d", f(), f()) - это обычный такой unspecified behavior,
 ничего загадочного здесь ожидать не приходится.

Undefined behavior в i = i++ + i++  связан с нарушением модели памяти C++. 
Конкретнее - с разрушением причинно-следственной связи и графов зависимостей потоков данных.
Даже без сильных ходов типа volatile, кэш-линий и конкурентного исполнения, это приводит к проблемам при оптимизации. 
Реальные артефакты включают не столько "недо-" или "перевычисление", 
сколько неверный маппинг текущих "физических" регистров на "логические" переменные, что сильно хуже.

Это знаменитая опечатка в ненормативной части стандарта. 
Она давно исправлена, но любители почитать стандарт без чтения его defect reports 
(и понимания разницы между нормативными и ненормативными частями) часто оказываются в луже.

У этой процессорной модели есть специальная команда sequence point. 
Которая форсирует наступление всех сайдэффектов с предыдущей sequence point. 
Сайдэффекты могут включать, к примеру, переименование физических регистров.
К примеру, ++i может увеличить register stack pointer, положив что-то там на его вершину. 
Если вспомнить x87 fpu - то модель не такая и абсурдная. 
Для красоты предположим, что регистровый стек адресуется с головы.
Стандарт позволяет процессорной модели свободное поведение внутри sequence point clause. 
К примеру, на двойной ++i внутри sequence point clause стек регистров может инкрементироваться один раз, 
может два.  Естественно, состояние физического процессора и представления о нем 
с точки зрения компилятора - разойдутся.

http://www.knosof.co.uk/cbook/cbook.html
По опыту, прочитавшие The New C Standard: An Economic and Cultural Commentary (про C) 
люди обычно сильно более полезны, чем прочитавшие стандарт C++ (про C++).

Добавлю, что если для чего и надо использовать C/C++ - так это как раз для резких движений на границе можно/нельзя. 
Например, для управления аппаратурой, минимизации сбросов кэшей, пуш-стриминга и прочих реально полезных вещей.
Или, скажем, для реализации тех же lock-free/pure-functional/persistent/whatever структур данных.
Но обсуждать реальные вещи с тем, для кого "Стандарт - это Закон"- глупо. 
Ибо вся красота решений - она в специфике и в деталях.

Встречаются два почтальона А и Б и у них получается вот такой разговор: 
А: Я знаю что у тебя есть 3 сына. Сколько им лет??? 
Б: Произведение их возрастов равно твоему возрасту. 
А: Нет, мне недостаточно информации. 
Б: Сумма их возрастов равна кол-ву окон вон в том здании. 
А: Ээээ.., все равно недостаточно  информации. 
Б: Мой средний сын рыжий. 
А: А, тогда все ясно!!! :)

Нужен равносторонний треугольник с целочисленными координатами вершин. В стандартной евклидовой метрике.
( 1, 0, 0 ) 
( 0, 1, 0 ) 
( 0, 0, 1 )

 Two numbers (not necessarily different) are chosen from the range of positive 
> integers greater than 1 and [b]not greater than 100.
> Only the sum of the two numbers is given to mathematician S. 
> Only the product of the two is given to mathematician P. 
> 
> On the telephone, S says to P: "I see no way you can determine my sum." 
> An hour later, P calls back to say: "I know your sum." 
> Later S calls P again to report: "Now I know your product." 
> 
> What are the two numbers?


/*
print("%08x\n", 42);
cout << setw(8) << setfill('0') << hex << 42 << endl;
This is the correct answer.  
The field width is set to 8, padding is set to the character 0 
and the output for integers is set to hexadecimal.  
This is the exact equivalent of the "%08x" format specification in the "printf()" C library function.
*/

/*
cin >> line1;
getline(cin, line2);
cout << "EOF\n";

It will print out: 
Line 1: Hello 
Line 2:  world! 
EOF
This is the correct answer.  
Although std::skipws is issued in the stream, 
std::getline() bypasses that mechanism, 
and the space that terminated the extraction will be read in.  
In addition, std::getline() never keeps the terminating newline in the destination string.
*/
