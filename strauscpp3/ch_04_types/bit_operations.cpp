#include <iostream>
#include "bit_operations.h"

// Побитовая арифметика
/*

& побитовое И
Оператор & (И) сравнивает два значения и возвращает значение 1, 
только в том случае, если оба значения были установлены в 1. 
Биты сравниваются используя следующую таблицу
1   &   1   ==   1
1   &   0   ==   0
0   &   1   ==   0
0   &   0   ==   0
Данный оператор лучше всего использовать для установки маски проверки значений определенных битов.
*/
void show_and(short b){
	
	if ( b & 0x10 )
		std::cout << "Fourth bit is set" << std::endl;
	else
		std::cout << "Fourth bit is clear" << std::endl;
}


/*
| побитовое ИЛИ
Оператор | (ИЛИ) сравнивает два значения и возвращает результат в виде единицы, 
если хотя бы один из битов будет установлен (равен единице). 
Биты сравниваются, используя следующую таблицу
1   |   1   ==   1
1   |   0   ==   1
0   |   1   ==   1
0   |   0   ==   0
Данный оператор лучше всего использовать для обеспечения установки каких-то определенных битов.
*/
void show_or(short b){
	//Допустим, мы хотим убедиться, что значение третьего бита установлено
	short c = b | 0x04;
	std::cout << "c = " << c << std::endl;
}


/*
^ побитовое исключающее ИЛИ
Оператор ^ (XOR) сравнивает два значения и возвращает единицу в случае, 
если значения сравниваемых элементов различаются. 
То есть в случае, если сравниваемые значения одинаковы, будет возвращено нулевое значение. 
Биты сравниваются, используя следующую таблицу
1   ^   1   ==   0
1   ^   0   ==   1
0   ^   1   ==   1
0   ^   0   ==   0
Идеальное использование такого оператора заключается в переключении определенных битов. 
*/

// Допустим, мы хотим изменить четвертый и пятый биты (0x18)
void show_xor(short b){
	std::cout << "b = " << b << std::endl;
	b = b ^ 0x18;
	std::cout << "b = " << b << std::endl;
	//В результате будут выполнены следующие подсчеты
	//	00110010  - b
	//^ 00011000  - ^ 0x18
	//	----------
	//	00101010  - result
}

/*
~ побитовое НЕ
Оператор ~ (поразрядное дополнение или обратный код) действует только на одно значение 
и инвертирует его, преобразуя все единицы в нули, а нули -  единицы. 
Данный оператор используется для установления определенных бит в ноль 
и обеспечения того, что все другие биты установлены в единицу, независимо от размера данных. 
*/

//Допустим, мы хотим установить все биты в единицу, за исключением нулевого и первого бита
void show_negate(){
	short b = ~0x03;
	std::cout << "b = " << b << std::endl;
	//В результате будут выполнены следующие подсчеты
	//00000011  - 0x03
	//11111100  - ~0x03  b
}


/*
<< >> сдвиги
то же самое с присваиванием

&& логическое И
|| логическое ИЛИ
!  логическое НЕ

*/

// Задача:
// С помощью побитовых операторов и операторов сдвига выведите значение "y"
// на консоль в двоичном виде, например:
// если y==9, то
// 0 0 0 0 ...   0 0 1 0 0 1 (всего 16 двоичных цифры)
void shift_output(short b){

	for( int i = 15 ; i >= 0  ; i-- ){
		
		// Сдвиг на инкрементное число
		short d = b >> i;
		
		// выводим последний бит
		short c = d & 0x1;
		std::cout << c;
	}
	std::cout << std::endl;
}

// То же самое, пропуская незначащие нули
void shift_output2(short b){

	bool leadzero = false;
	for( int i = 15 ; i >= 0  ; i-- ){
		short d = b >> i;
		short c = d & 0x1;

		// Как только закончились незначащие нули,
		// начинаем побитовый вывод
		if( c || leadzero){
			leadzero = true;
			std::cout << c;
		}
	}
	std::cout << std::endl;
}

//"Сдвиньте" все единицы в сформированном значении вправо, например:
//было:   0100 1111 0000 0000 0110 1111 0000 0010
//стало:  0000 0000 0000 0000 0000 1111 1111 1111
void shift_collect(short b){
	
	short mask = 0;
	short fill1 = 0x1;
	for( int i = 15 ; i >= 0 ; i-- ){
		
		// Пробежимся по всем битам
		short d = b >> i;
		short c = d & 0x1;
		std::cout << c;
		
		// при нахождении единичных - 
		// установить крайний справа бит и сдвинуть маску
		if(c == 0x1){
			mask |= fill1;
			fill1 <<= 1;
		}
	}
	std::cout << std::endl;
	// вывести результат в двоичном виде
	shift_output(mask);
}

// !(!a && !b)
//a || b
//This is correct.  NOT (NOT A  AND  NOT B) equals A OR B.  Conversely, NOT (NOT A  OR  NOT B) equals A AND B.


void show_bits(){

	show_and(50);
	show_or(50);
	show_xor(50);
	show_negate();
	shift_output(2);
	shift_output2(8);
	shift_collect(12);
}