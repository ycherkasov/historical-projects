#pragma once

/*
Для использования указателя или ссылки на шаблон, так же как и для класса, не обязательно
определять его полностью - достаточно forward declaration
*/ 

template <typename T> class C;

struct TemplatePreuse{
	TemplatePreuse():pc(){}
	C<int>* pc;
};

// Теперь определим этот класс
template <typename T> class C{
public:
	void func(){}
};

// А для использования экземпляра класса или метода уже нужно полное его определение
void show_defined(){
	C<int> c;
	c.func();
}

// При инстанцировании шаблона реализуется код только для используемых членов класса
// (так называемое "ленивое инстанцирование")
// Исключения составляют только неименованные объединения и виртуальные функции

// Для примера реализуем шаблон класса, в котором не определены почти все члены
// Если бы это был не шаблон, линкер вернул бы ошибку
// Но т.к. неиспользуемые члены класса не инстанцируются, ошибки нет

template <typename T>
struct Safe{};

template <int N>
struct Danger{
	// Если N<=0 - ошибка
	char block[N];
};

template <typename T, int N>
class InstantByRequest{
public:
	// виртуальные функции инстанцируются всегда - нужно определение
	virtual ~InstantByRequest(){

	}

	// Только объявление, без определения
	void no_body_this_function(Safe<T> s);

	// Если бы инстанцировалась эта функция, мы получили бы массив нулевого размера (ошибка)
	void inclass(){
		Danger<N> no_boom;
	}

	// operator-> не определен и возвращает T, но ошибки нет
	T operator->();

	struct Nested{
		Danger<N> d;
	};

	union{
		int align;
		Safe<T> anonimous;
	};
};

// Точка инстанцирования - это место в коде, куда по факту будет встроено
// сгенерированный инстанс шаблона
// Для шаблонов функций это - самое дальнее место в единице трансляции.
// Для шаблонов классов - ближнее место в области видимости вызова.

/*
Основные стратегии инстанцирования, применяемые в компиляторах:
1. Жадное инстанцирование - может инстанцироваться несколько экземпляров одного и того же шаблона.
   При этом ассемблерный код может незначительно отличатсья. 
   Плюсы - простота компиляции.
   Минусы - скорость компиляции, дублирование кода.
2. Инстанцирование по запросу. Компилятор содержит таблицу инстанцирований в файле,
   и при необходимости инстанцирования шаблона ищет его готовую реализацию.
   Если реализация уже есть, но код с прошлой компиляции изменился, она обновляется.
   Если реализации нет, она добавляется.
   Плюсы - компактный код.
   Минусы - сложности при разработке линкера.
3. Итеративное инстанцирование. При этом подходе исходный код компилируется и пытается слинковаться, 
   потом анализируются ошибки линкера и итерация повторяется.
   Плюсы - компактность сгенерированного кода.
   Минусы - время линковки.
*/
