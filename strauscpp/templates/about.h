/** @brief 
Глава 13 Страуструпа
Главы 11,12 Лаптева
Шаблоны.
*/

/*
Сделать:
1. Реализовать реальное сравнение строк в show_special()
2. Статические члены шаблонов - копия для кажлого инстанцирования (Страуструп стр.390)
*/

/*
Вопросы:
1. Как реализовать typedef для указателя на шаблонную функцию
2. Немного непонятно с частичной специализацией
3. Реализация адаптеров для указателей на члены (упражнение 12.11 из Лаптева)
4. С конструкторами копирования и операторами присванивания - разобраться.
5. Порядок разрешения видимости при перегрузке и специализации.
*/

/*
Советы:
1. Хорошей практикой является протестировать класс или функцию до преобразования в шаблон.
2. Хорошей практикой является создание частичных специализаций для контейнеров указателей.
3. Всегда объявляйте общую форму шаблона до специализаций.
4. Объявляйте частичные специализации для строк и массивов.
5. Используйте аргументы шаблона для выбора алгоритмов.
6. Используйте шабоны для определения преобразоваий.
7. Ограницивайте и проверяйте аргументы шаблона (концепты, SFINAE)
8. Отдавайте предпочтение шаблонам перед производными классами, 
   когда эффективность времени выполнения имеет значение.
9. Отличия шаблона функции от шаблона класса:
   - возможна перегрузка с обычными функциями
   - невозможны параметры по умолчанию
   - невозможна частичная специализация
10.typename можно заменить на class, но так лучше не делать. Если параметр шаблона 
   - тип, то используйте typename typename T - общепринятая форма
11.Одна специализация считается более специализированной чем другая,
   если каждый список аргументов соответствует первой специализации
12.Вызов метода по указателю - операция .* или ->*
13.Указатель на обычный метод нельзя присвоить указателю на функцию, а на статический - можно
14.Полезно улучшить читабельность класса введением typedef.
15.Шаблоны могут быть друзьями и у шаблонов могут быть друзья.
16.Дружественные функции шаблона лучше определять в самом шаблоне (это делается для удобства приведения типов)
17.Нетиповые параметры шаблонов могут быть: целочисленными константами, указателями на объекты с внешним связыванием.
18.Параметр шаблона может быть использовать для последующего определения других параметров.
19.Наследование шаблона от класса - статический счетчикэкземпляров объекта.
20.С точки зрения С++ два класса, сгенерированные из одного шаблона, не связаны никакими отношениями наследования.
21.Реализуйте обобщенные алгоритмы методами шаблонов. Передавайте алгоритмы параметрами.
22.Можно использовать абстрактный класс шаблона.
*/
