/** @brief 
Глава 14, приложение Д Страуструпа
Глава 7 Лаптева
Обработка исключений
Производные исключений. Управление ресурсами. Конструкторы и деструкторы.
Стандартные исключения
*/

/*
Сделать:
1. Посмотреть на раскрутку стека
2. Посмотреть приложение Д
3. Пример - Страус стр. 429-434 со спецификациями
4. Как завернуть SEH
5. Разобраться с примером деления на 0

*/

/*
Вопросы:
1. А вложенные функции тоже поддерживают спецификацию?
2. set_new_handler() - разобраться!
*/

//exception 
// <- bad_alloc					new
// <- bad_cast					dynamic_cast
// <- bad_exception				спецификация исключения
// <- bad_typeid				typeid
// <- bad_ios_base::failure		ios_base::clear()
// <- logic_error				Логические ошибки
//		<- domain_error 
//		<- invalid_argument		bitset()
//		<- length_error		
//		<- out_of_range			at(), bitset<>::operator[]
// <- runtime_error				Ошибки времени выполнения
//		<- range_error 
//		<- overflow_error		bitset::to_ulong()
//		<- underflow_error



/*
Советы:
1. Пользуйтесь исключениями в main(), в т.ч. catch(...)
2. Не пользуйтесь исключениями, когда достаточно локальных управляющих конструкций.
3. Пользуйтесь принципом "выделение ресурсов есть инициализация"
4. Генерируйте исключения для указания на ошибку в конструкторе
5. Не генерируйте исключения в деструкторах
6. В большом проекте наследуйте от общего класса исключений.
7. Гарантируйте освобождение каждого ресурса в конструкторе в случае исключения.
8. Пользуйтесь спецификацией исключения.
7. Библиотека не должна сама прекращать выполнение программы или выводить отладочную информацию.
8. Разрабатывайте стратегию обработки ошибок на ранних стадиях проектирования.
9. Пользуйтесь умными указателями.
10.Конструкторы по умным указателям обычно объявляют explicit.
11.auto_ptr реализует семантику владения (или деструктивного копирования)
12.Механизм SEH непереносим с платвормы Win и не вызывает деструкторы при раскрутке стека.
13.unexpected() вызывается при нарушении спецификации исключений. Можно подменить по set_unexpected()
14.Полным аналогом unexpected() является конструкция catch(...) в main() Можно кидать bad_exception из unexpected()
15.terminate() вызывается при вызове неперехваченного исключения. 
16.Стандартно вызывает abort() 
   Можно подменить вызов чтобы, например, вызвать exit(0) - он хотя бы вызовет деструкторы.
17.Контролируемый конструктор - перехватывает все исключения даже в списке инициализации ( и передает их далее )
18.Контролируемый метод перехватывает все исключения в себе.
19.Если одно исключние кинет другое - программа упадет по terminate()
20.Пользуйтесь стандартными исключениями. Разделяйте те, которые кидает STL и которые должен кидать пользователь.
21.Объем памяти гарантированно достаточен для исключения bad_alloc.
22.Нельзя использовать в качестве элементов контейнера стандартный указатель auto_ptr,
   потому что операция копирования auto_ptr обнуляет исходный указатель
23.catch(...) обрабатывает все SE безусловно
24.Cледует транслировать SE в С++ исключение установив _set_se_translator()
25.Если ссылка, по которой обрабатывается исключение неконстантна, теоретически можно модифицировать
   исключение перед проброской далее. Но так лучше не делать.
*/
