Глава 12 Страуструпа
Глава 9 Лаптева
Мейерс 1 Глава 6
Производные классы. Иерархия классов. 
Наследование реализации.
Виртуальные функции. Абстрактные классы. 
Проектирование иерархий классов.


Вопросы


Сделать:
1. Пример из Страуструпа с защищенным наследованием( стр. 363 )
2. Примеры со счетчиком ссылок (Мейерс 2-29)


// Абстрактные классы широко применяются в паттернах проектирования и технологии COM.

// Принцип подстановки Лисков:
// Основная идея такова: функция, использующая ссылку или указатель на базовый класс 
// должна уметь работать и с классами-наследниками, без их распознавания.
// http://forums.realcoding.net/index.php?showtopic=16693


Консистентность, в данном случае, означает соответствие значений всех переменных объекта его состоянию. 
Например, объект-строка имеет две переменные: указатель блока памяти и длину строки. 
Присваивая объекту более длинную строку, мы должны освободить старый блок памяти, выделить новый, 
скопировать строку, изменить значение указателя и значение длины. Перед выполнением первой 
из этих операций, данные объекта консистентны, после выполнения последней — тоже. 
Между первой и последней операциями, консистентность нарушена.

Правило 1: При возврате из любого public метода, данные объекта должны быть консистентны.
Правило 2: Перед выполнением исходящего вызова следует обеспечить консистентность данных объекта.
Правило 3: Необходимо учитывать, что, за время исходящего вызова, состояние объекта может быть изменено.

	In order to control these types of conversions between classes, 
	we have four specific casting operators: 
	dynamic_cast, reinterpret_cast, static_cast and const_cast. 
	Their format is to follow the new type enclosed between angle-brackets (<>) and immediately after, 
	the expression to be converted between parentheses.

	dynamic_cast <new_type> (expression)
	reinterpret_cast <new_type> (expression)
	static_cast <new_type> (expression)
	const_cast <new_type> (expression)

	The traditional type-casting equivalents to these expressions would be:

	(new_type) expression
	new_type (expression)

	static_cast can perform conversions between pointers to related classes, 
	not only upcasts (from pointer-to-derived to pointer-to-base), 
	but also downcasts (from pointer-to-base to pointer-to-derived). 
	No checks are performed during runtime to guarantee that the object being converted 
	is in fact a full object of the destination type. 
	Therefore, it is up to the programmer to ensure that the conversion is safe. 
	On the other side, it does not incur the overhead of the type-safety checks of dynamic_cast.

	dynamic_cast can only be used with pointers and references to classes (or with void*). 
	Its purpose is to ensure that the result of the type conversion points to a valid 
	complete object of the destination pointer type.
	This naturally includes pointer upcast (converting from pointer-to-derived to pointer-to-base), 
	in the same way as allowed as an implicit conversion.
	But dynamic_cast can also downcast (convert from pointer-to-base to pointer-to-derived) 
	polymorphic classes (those with virtual members) if -and only if- 
	the pointed object is a valid complete object of the target type.


	reinterpret_cast converts any pointer type to any other pointer type, even of unrelated classes. 
	The operation result is a simple binary copy of the value from one pointer to the other. 
	All pointer conversions are allowed: neither the content pointed nor the pointer type itself is checked.

	This type of casting manipulates the constness of the object pointed by a pointer,



Советы:
1. Не используйте поля хранящие информацию о типе.
2. Не передавайте объекты по значению во избежание срезки.
3. Переопределяйте конструктор повышающего преобразования для того же 
    (явно вызывая метод или конструктор родительского класса в функциональной форме).
4. Пользуйтесь абстрактными классами для 
   - определения интерфейса
   - установления контракта
   - реализации по умолчанию (хотя в ряде случаев имеет смысл ее отделить)
5. В виртуальных классах стоит иметь виртуальный деструктор.
6. Абстрактный класс обычно не нуждается в конструкторе
7. Общепринятая практика - наследовать классы от классов (т.е. структуры в наследовании не участвуют)
8. Конструктор не наследуется - он создается по умолчанию или реализуется явно
9. Также не наследуются операторы присваивания и дружественные функции
10.Деструкторы вызываются в порядке, обратном конструктору, и не наследуются
11.Добавляемые поля могут совпадать по имени с полями базового
12.Хотя так делать не рекомендуется (в этом случае базовый член класса замещается производным)
13.В производном списке инициализации нельзя инициализировать члены базовых классов, но можно в теле конструктора
14.Методы базового класса можно вызывать явно.
15.Пользуйтеся закрытым или защищенным наследованием для сокрытия интерфейса базового класса (паттерн Адаптер)
16.Для этого же можно пользоваться агрегированием (композицией)
17.Иерархия классов может быть нециклическим графом. Глубина иерархии ничем не ограничена.
18.В базовом классе необходимо хранить только _самые_ общие данные во избежание дополнительных зависимостей
19.В производных классах виртуальные функции реализуются только если в этом есть необходимость
20.Можно объявить и определить чисто виртуальный деструктор. Он будет нормально вызываться и не наследоваться.
   Т.е. класс-наследник абстрактным не является. (он будет играть роль деструктора по умолчанию)
21.В абстрактном классе можно реализовать не чисто виртуальные методы и вызывать их для производных классов.
22.Можно "виртуализировать" внешние функции (например друзья) путем передачи ссылки 
   на базовый класс с виртуальностью.
23.Можно указывать using::f, чтобы переопределить родительский метод вместо собственного в классе
24.Значения по умолчанию в списке параметров виртуальной функции наследуются!
25.Возвращаемое значение виртуальной функции в разных классах может отличаться, если это:
  - указатель или ссылка
  - они приводятся друг к другу
26. Операторы могут быть виртуальными.
27. Формат VTBL определяется ABI.
28. В конструкторе или деструкторе вызываются только свои виртуальные методы.
29.В случае закрытого наследование также не работает приведение по ссылку-указателю к базовому классу.
30.Для реализации адаптера предпочитайте композицию. Используйте наследование, только когда обязаны так сделать.
   (доступ к защищенным членам, виртуальность)

In VC++, the vtable pointer stored at the beginning of the object allocation, 
before any member data. (Provided your class has at least one virtual member function.)
There also may be multiple vtable pointers, if your class multiply-inherits from other classes with vtables.
The vtables themselves are statically allocated somewhere in your address space.

Обычно компилятор создает отдельную vtable для каждого класса. 
После создания объекта указатель на эту vtable, называемый виртуальный табличный указатель или vpointer, 
добавляется как скрытый член данного объекта (а зачастую как первый член). 
Компилятор также генерирует «скрытый» код в конструкторе каждого класса 
для инициализации vpointer'ов его объектов адресами соответствующей vtable.

При множественном наследовании в классе содержится несколько vtbl и указателей на виртуальный класс
RTTI тоже содержится в vtbl
ВАЖНО! Схема расположения в памяти данных и vtbl


Мейерс 1

// Правило 35 Открытое наследование - в большинстве случаев это отношение "есть разновидность".
// При проектировании тщательно выбирайте базовую сущность (классический пример "квадрат-прямоугольник")

// Правило 36. Если функция невиртуальная, скорее всего она наследуется всегда и для всех
// Если функция чисто виртуальная, наследуется интерфейс.
// Если функция чисто виртуального класса определена, наследуется реализация по умолчанию
// Если реализация по умолчанию подходит не для всех, необходимо либо выделить иерархию,
// либо реализовать невиртуальный метод, вызываемый вручную, типа default(). 
// Тогда если переопределенный метод не будет реализован, производный класс не скомпилируется.

// Правило 38 - значение аргумента по умолчанию связывается статически, поэтому наследуется

// Правило 42 - при закрытом наследовании не только закрывается интерфейс, но и не работает принцип подстановки
// Закрытое наследование означает отношение "реализуется посредством"
// Выбор между агрегацией и закрытым наследованием: агрегация - если возможно, наследование - если необходимо

// По умолчанию реализуются: конструктор по умолчанию, копирования, =, деструктор, 
// и можно сказать, что операторы * ->
// Если определен один конструктор, конструктор по умолчанию не создается
// Если определена неконстантная версия копирования (присвоения), константная не создается
// Оператор присвоения по умолчанию не работает со ссылками

Мейерс 2

21. Не делайте объекты виртуальными без надобности. 
inline игнорируется для c virtual, но это не ошибка
