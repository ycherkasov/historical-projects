/*
Глава 10 Страуструпа
Главы 1,2,4,5 Лаптева
Глава 2,4 Мейерса
В проекте рассматриваются классы, члены классов, 
константные и статические члены классов,
константные и статические классы,
mutable, временные объекты, объединения.


Вопросы:
3. Нужно ли явно определять деструктор(в случае 1 в том числе)?

Сделать:
1. operator new() со сборкой мусора
2. Memory pool (see user_alooc.h)

Советы
1. Представляйте все концепции в виде классов.
2. Пользуйтесь структурами если класс маленький 
   либо является просто композицией разнородных данных.
3. Не добавляйте в класс большое число конструкторов, просто потому 
   что они когда-нибудь могут понадобиться.
4. Объявляйте по возможности функции-члены как const.
5. При копировании проверяйте копирование самому себе.
6. Пользуйтесь неименованными перечислениями для объявления констант.
7. Глобальным объектам предпочитайте синглтоны.
8. Закрытые данные следует помещать в конец класса, чтобы сделать акцент на открытом интерфейсе.
9. Корректно определяйте константный указатель  - char *const p;
   и указатель на константу char const* p (const char* p)
10.Неконстантный метод не м.б. вызван в константном экземпляре.
11.При необходимости пользуйтесь запрещением копирования.
12.Отличия конструктора от метода - конструктор не м.б. виртуальным или статическим,
   не возвращает результата.
13.Элементы массива-члена могут быть сконструированы только по умолчанию.
   Это делает практически безполезными константные массивы-члены.
   Исключение составляет статический массив.
14.Конструкторы глобальных объектов вызываются в одном модуле - в порядке определения,
   в разных модулях - порядок не определен. То же для разрушения объектов.
15.Конструкторы статических объектов вызываются при первом использовании, 
   разрушаются в порядке, обратном конструированию. Момент разрушения не определен.
16.Член объединения (union) не может иметь членов с конструкторами-деструкторами
   т.к. в общем случае непонятно какой из них вызывать.
17.В конструкторе по умолчанию используйте аргументы по умолчанию.
18.Если класс содержит константы или ссылки в качестве членов,
   конструктор по умолчанию не может быть вызван.
19.Нестатический массив-член может быть проинициализирован нулями ()
20.Существует неоднозначность при вызове целочисленных параметров и указателей (передача 0 - int)
   Они также наследуются всеми потомками класса.
22.При возвращении больших объектов по значению пользуйтесь оптимизацией в виде
   статического кэша.
23.Существуют 3 формы оператора new.
24.В некоторых случаях (замещающий вызов new) деструктор может быть вызван явно.
25.Размер класса не всегда равен размеру его членов (выравнивание)
26.Набор эффективных конкретных классов составляет фундамент приложения.
   Тщательно проектируйте классы.
27. Разрешается определять структуру и не структуры одного имени (то же для class, enum, union)
28. При замещении operator new() делайте его членом класса.
29. Компилятор не сгенерирует константный operator=(const A&) если явно определен неконстантный operator=(A&)!
30. typedef с массивом не работает!
31. При нехватке памяти можно ловить bad_alloc или вызывать set_new_handler
32. set_new_handler() вызывается, пока память не будет освобождена или программа не завершена
33. Можно для каждого конкретного класса реализовать свой обработчик set_new_handler() в виде статического члена
34. Можно создать класс-примесь (mixture) чтобы наследовать от него оператор и обработчик new
35. Применение set_new_handler удобнее, чем обрамление кода блоками try. Он работает со всеми формами new.
36. operator new() наследуется производными классами
37. Также реализуйте родственный operator new[]()
38. Нормальная форма new() обязательно должна быть перегружена
39. Когда известны все возможные размеры объектов, можно создать для каждого из них пул памяти
	Его удобно реализовать классом
*/