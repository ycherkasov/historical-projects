/*
Главы 2-5 Джосаттиса
Простые шаблоны функций. Простые шаблоны классов.
Специализация, частичная специализация, аргументы по умолчанию.
Ключевое слово typename. Конструкция X.template.
Использование this-> 
Шаблоны - члены классов. Шаблонные параметры.
Инициализация нулем. Использование литералов.
*/

/*
Сделать:
*/

/*
Вопросы:
*/

/*
Резюме и советы:
1. Для шаблонных функций возможна перегрузка, как с другими шаблонными функциями,
   так и с просто функциями.
2. При этом можно явно указывать использование шаблона через <>
3. При использовании одной перегрузки в другой нужно следить за порядком объявления.
4. Если параметр шаблона - тип, то используйте typename. typename T - общепринятая форма.
5. Код шаблона компилируется 2 раза - при проверке синтаксической правильности и при инстанцировании
6. Необходимо, чтобы каждая операция для элемента шаблона была допустима.
7. Чтобы передавать в шаблон параметры разных типов, надо:
   - перегрузить обычную функцию, чтобы совершалась неявная подстановка
   - использовать несколько параметров шаблона typename
8. Шаблонные функции м.б. встраиваимыми (inline).
9. Инстанцирование в классах происходит только для вызываемых методов
10.Для специализируемого шаблона <T> в методах болше не указывают и template <> в определении методов не пишут.
11.Частичная специализация - когда параметров насколько, но специализируется один из них.
   Например "оба параметра одинаковые, второй параметр int, оба параметра - указатели"
   При  этом необходимо следить за неоднозначностями!
12.Аргументы по умолчанию д.б. последними в списке аргументов.
13.Нетиповые параметры шаблонов могут быть
   - целочисленными константами (int, long)
   - указателями на объекты с внешним связыванием
14.Ключевое слово typename используется не только для указания параметров-типов,
   но и для указания, что данная конструкция, производная от параметра, является типом
   Применение ключевого слова typename к итератору - стандартный прием.
15.Для членов классов шаблона нужно явно указывать this-> Это необходимо в том числе для достижения виртуальности!
   Дело в том, что при разрешении имен сначала рассматриваются внешние фукнкции.
   Для статических методов также нужно явно указывать Base<T>::
16.Шаблонный метод или класс м.б. членом класса (как шаблонного, так и обычного)
   Такие методы при реализации вне класса имеют две конструкции template <>
17.Параметром шаблона может быть шаблон. 
18.Шаблонные параметры и частичная специализация допускаются только для шаблонов классов.
19.Шаблонные параметры можно инициализировать нулем ()
20.Преобразование массива (строкового литерала ) в указатель присходит только в случае, 
   если имя массва передается по значению
21.Для предотвращения подобных ситуаций:
   - передавать по значению
   - использовать передачу по ссылке (или перегрузку для массивов)
   - не использовать С-строки (предпочтительно)
   Первый способ применен в std::make_pair(f, s) - оба параметра по значению для передачи литералов
22.Вывод типов возможен только для функций
*/